// Example IDL file for our monster's schema.

// TODO(gmagogsfm): Update namespace.
namespace torch.jit.mobile.serialization;

struct Int {
  int_val:int;
}

struct Bool {
  bool_val:bool;
}

struct Double{
  double_val:double;
}

struct PerTensorAffineSchema {
  q_scale:double;
  q_zero_point:int;
}
union QSchema {}

table TensorMetadata {
  // TODO(quantized?)
  // torch._utils _rebuild_tensor_v2
  storage_location_index:int;
  // enum ScalarType
  scalar_type: byte;
  storage_offset:int;
  nbytes:long;
  element_size:int;
  sizes:[int];
  strides:[int];
  requires_grad:bool;
}

table String {
  data: string;
}

// Is it needed to represent other types?
union IValue {
  Int,
  Bool,
  Double,
  TensorMetadata,
  String,
  List,
  Tuple,
  Dict,
  Object,
}

table List {
  items: [IValue];
}

table Tuple {
  items: [IValue];
}

table Dict {
  keys: [IValue];
  values: [IValue];
}

table ObjectType {
  type_name:string;
  attr_names:[string];
}

table Object {
  type_index: int;
  use_setstate:bool;
  state: IValue;  
}

struct Instruction {
  // Should op be enum instead?
  op:byte;
  n:ushort;
  x:int;
}

table Operator {
  name:string;
  overload_name:string;
  num_args_serialized:int = -1;
}

table Arg {
  name:string;
  // Why do we use string to represent types
  // rather than index into Code.types?
  type:string;
  default_value:IValue;  // position into ivalues
}

table Schema {
  arguments:[Arg];
  returns:[Arg];
}

table DebugInfo {
  debug_handle:[long];
}

table Function {
  qn:string;
  instructions:[Instruction];
  operators:[Operator];
  constants:[IValue];
  types:[string];
  register_size:int;
  schema:Schema;
  debug_info:DebugInfo;
}

table Module {
  methods:[Function];

  types:[ObjectType];  // type information of objects used

  // this is module._ivalue()
  state_obj: Object;

  storage_count: int;
}

root_type Module;