import math
from enum import Enum
from typing import Any

import torch


class ScalarDtype(Enum):
    bool = bool
    int = int
    float = float


SUPPORTED_TENSOR_DTYPES = [
    torch.bool,
    torch.uint8,
    torch.int8,
    torch.int16,
    torch.int32,
    torch.int64,
    torch.float32,
    torch.float64,
    # The following types are not supported yet, but we should support them soon:
    # torch.float16,
    # torch.complex32,
    # torch.complex64,
    # torch.complex128,
    # torch.bfloat16,
]


class VariableType(Enum):
    """
    These are the most basic variable types generated by Inputgen.
    More complex structures can be created using these as building blocks.
    """

    Bool = bool
    Int = int
    Float = float
    String = str
    ScalarDtype = ScalarDtype
    TensorDtype = torch.dtype
    Tuple = tuple

    @staticmethod
    def contains(v: Any) -> bool:
        return v in [member.value for member in VariableType]


def invalid_vtype(vtype: type, v: Any) -> bool:
    if v is None:
        return False
    if vtype in [bool, int, float]:
        if type(v) not in [bool, int, float]:
            return True
    else:
        if not isinstance(v, vtype):
            return True
    return False


def is_integer(v: Any) -> bool:
    if type(v) not in [bool, int, float]:
        return False
    if math.isnan(v) or not math.isfinite(v):
        return False
    return bool(int(v) == v)


def convert_to_vtype(vtype: type, v: Any) -> Any:
    if vtype == bool:
        return bool(v)
    if vtype == int:
        if not is_integer(v):
            return v
        return int(v)
    if vtype == float:
        return float(v)
    return v
