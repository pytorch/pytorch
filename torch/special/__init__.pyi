# Stub file for torch.special
import torch
from torch import Tensor

# Error functions
def erf(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def erfc(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def erfcx(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def erfinv(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...

# Exponential and logarithmic functions
def exp2(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def expm1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def expit(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def log1p(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def log_softmax(
    input: Tensor,
    dim: int,
    *,
    dtype: torch.dtype | None = None,
) -> Tensor: ...
def logit(
    input: Tensor,
    eps: float | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def logsumexp(
    input: Tensor,
    dim: int | tuple[int, ...],
    keepdim: bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def softmax(
    input: Tensor,
    dim: int,
    *,
    dtype: torch.dtype | None = None,
) -> Tensor: ...
def xlog1py(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def xlogy(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...

# Gamma functions
def gammaln(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def digamma(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def polygamma(n: int, input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def multigammaln(input: Tensor, p: int) -> Tensor: ...
def gammainc(input: Tensor, other: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def gammaincc(input: Tensor, other: Tensor, *, out: Tensor | None = None) -> Tensor: ...

# Bessel functions
def i0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def i0e(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def i1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def i1e(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def bessel_j0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def bessel_j1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def bessel_y0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def bessel_y1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def modified_bessel_i0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def modified_bessel_i1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def modified_bessel_k0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def modified_bessel_k1(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def scaled_modified_bessel_k0(
    input: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def scaled_modified_bessel_k1(
    input: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def spherical_bessel_j0(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...

# Other special functions
def airy_ai(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def chebyshev_polynomial_t(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def chebyshev_polynomial_u(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def chebyshev_polynomial_v(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def chebyshev_polynomial_w(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def entr(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def hermite_polynomial_h(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def hermite_polynomial_he(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def laguerre_polynomial_l(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def legendre_polynomial_p(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def log_ndtr(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def ndtr(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def ndtri(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def shifted_chebyshev_polynomial_t(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def shifted_chebyshev_polynomial_u(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def shifted_chebyshev_polynomial_v(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def shifted_chebyshev_polynomial_w(
    x: Tensor, n: Tensor, *, out: Tensor | None = None
) -> Tensor: ...
def sinc(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def zeta(input: Tensor, other: Tensor, *, out: Tensor | None = None) -> Tensor: ...

# Rounding
def round(input: Tensor, *, decimals: int = 0, out: Tensor | None = None) -> Tensor: ...
