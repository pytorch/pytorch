diff --git a/aten/src/ATen/native/CPUBlas.cpp b/aten/src/ATen/native/CPUBlas.cpp
index 9db5a96fb7e..c2bee5103ba 100644
--- a/aten/src/ATen/native/CPUBlas.cpp
+++ b/aten/src/ATen/native/CPUBlas.cpp
@@ -363,10 +363,18 @@ void gemm(
 #endif
 #if AT_BUILD_WITH_BLAS() && (defined(BLAS_HAS_SBGEMM) || defined(BLAS_HAS_BGEMM))
    if (use_blas_gemm(transa, transb, m, n, k, lda, ldb, ldc)) {
+      // ADD PRINTF HERE
+      std::printf(">>> HIT BLAS GEMM bfloat16 path: m=%ld n=%ld k=%ld\n",
+                  (long)m, (long)n, (long)k);
+      std::fflush(stdout);
       int m_ = m, n_ = n, k_ = k, lda_ = lda, ldb_ = ldb, ldc_ = ldc;
       char transa_ = to_blas(transa), transb_ = to_blas(transb);
       // C matrix in OpenBLAS sbgemm are of type "float" so we have to convert, copy and copy back.
 #if defined(BLAS_HAS_BGEMM)
+      // ADD PRINTF HERE
+      std::printf(">>> Using OpenBLAS BGEMM (bfloat16) m=%d n=%d k=%d\n",
+                  m_, n_, k_);
+      std::fflush(stdout);
       at::BFloat16 alpha_ = c10::convert<at::BFloat16>(alpha);
       at::BFloat16 beta_ = c10::convert<at::BFloat16>(beta);
       bgemm_(&transa_, &transb_,
@@ -377,6 +385,10 @@ void gemm(
              &beta_,
              c, &ldc_);
 #else
+      // ADD PRINTF HERE
+      std::printf(">>> Using OpenBLAS SBGEMM (fallback float buffer) m=%d n=%d k=%d\n",
+                  m_, n_, k_);
+      std::fflush(stdout);
       // C matrix in OpenBLAS sbgemm are of type "float" so we have to convert, copy and copy back.
       int c_size = n_ * m_;
       std::vector<float> float_v(c_size, 0.0f);
@@ -398,10 +410,13 @@ void gemm(
           c[j * ldc_ + i] = c10::convert<at::BFloat16>(float_v[j * m_ + i]);
         }
       }
-#endif // 
+#endif // end of defined(BLAS_HAS_BGEMM)
       return;
    }
 #endif
+   // ADD PRINTF HERE
+   std::printf(">>> Using gemm_stub fallback path (not BLAS)\n");
+   std::fflush(stdout);
    gemm_stub(
       at::kCPU, at::kBFloat16,
       transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
