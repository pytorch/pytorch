# Fusion Regions Integration Summary

## Problem Statement
The user requested to add fusion regions functionality to the current commit in PyTorch's overlap scheduling system. The goal is to detect groups of fusible operations (pointwise, reduction, views, indexing ops) and treat them as regions for better overlap scheduling with communication operations.

## Solution Overview
Restored the full fusion regions implementation from commit `58f0b0c80fc` and integrated it into the current overlap scheduling pipeline.

## Changes Made

### 1. torch/_inductor/fx_passes/fusion_regions.py
**Status**: Completely rewritten (111 lines → 313 lines)

**Full File Contents**:
```python
"""Detect fusion regions for overlap scheduling."""

import operator
from dataclasses import dataclass

import torch
import torch.fx as fx
from torch.utils._ordered_set import OrderedSet


@dataclass
class FusionRegion:
    """Represents a connected set of fusible operations that will fuse together."""

    nodes: OrderedSet[fx.Node]  # All nodes in topo order
    cost_ms: float = 0.0  # Estimated cost in milliseconds
    external_inputs: OrderedSet[fx.Node] = None  # Inputs from outside the region
    external_outputs: OrderedSet[fx.Node] = None  # Nodes with users outside the region
    external_users: OrderedSet[fx.Node] = None  # Users outside the region
    subgraph_node: fx.Node | None = None  # The subgraph node representing this region

    def __post_init__(self):
        """Compute cost and external inputs/outputs."""
        from torch._inductor.utils import get_gpu_dram_gbps

        region_set = set(self.nodes)
        self.external_inputs = OrderedSet()
        self.external_outputs = OrderedSet()
        self.external_users = OrderedSet()

        for node in self.nodes:
            # Collect all external inputs (not just tensors)
            for inp in node.all_input_nodes:
                if inp not in region_set:
                    self.external_inputs.add(inp)

            # Collect all external outputs (not just tensors)
            if any(u not in region_set for u in node.users) or len(node.users) == 0:
                self.external_outputs.add(node)

            # Collect all external users
            for user in node.users:
                if user not in region_set:
                    self.external_users.add(user)

        # Calculate cost from tensor metadata of external IO
        total_bytes = 0
        for node in self.external_inputs | self.external_outputs:
            val = node.meta.get("val")
            if not isinstance(val, torch.Tensor):
                continue

            total_bytes += val.numel() * val.element_size()

        if total_bytes > 0:
            fusion_bw_gbps = get_gpu_dram_gbps()
            fusion_bw_bytes_per_s = fusion_bw_gbps * 1e9
            self.cost_ms = (total_bytes / fusion_bw_bytes_per_s) * 1000

    @property
    def start(self) -> fx.Node:
        """First node in the region."""
        return next(iter(self.nodes))

    @property
    def end(self) -> fx.Node:
        """Last node (anchor) in the region."""
        return list(self.nodes)[-1]


def is_fusible_node(n: fx.Node) -> bool:
    """Check if a node is fusible (pointwise, reduction, views, indexing ops).

    Excludes: mm/conv, collectives, waits, placeholders, outputs.
    """
    # Include pointwise, reduction, views
    tags = getattr(n.target, "tags", ())
    if torch.Tag.pointwise in tags or torch.Tag.reduction in tags:
        return True

    if getattr(n.target, "is_view", False):
        return True

    # Include specific indexing ops
    aten = torch.ops.aten
    if n.target in (aten.slice.Tensor, aten.gather.default, aten.embedding.default):
        return True

    return False


def build_fusion_regions(
    graph_nodes: list[fx.Node],
) -> dict[fx.Node, FusionRegion]:
    """Build fusion regions from the graph.

    Returns a dict mapping each node to its containing region (if any).

    Algorithm:
    1. Split graph into segments separated by non-fusible nodes
    2. Within each segment, group connected nodes via data dependencies
    """
    # Find segments: consecutive fusible nodes separated by non-fusible nodes
    segments: list[list[fx.Node]] = []
    current_segment: list[fx.Node] = []

    for node in graph_nodes:
        if is_fusible_node(node):
            current_segment.append(node)
        else:
            if current_segment:
                segments.append(current_segment)
                current_segment = []

    if current_segment:
        segments.append(current_segment)

    # Build fusion regions within each segment
    region_of: dict[fx.Node, FusionRegion] = {}

    for segment in segments:
        if len(segment) < 2:
            continue

        segment_set = set(segment)
        # Map each node to its region members (initially just itself)
        node_to_region: dict[fx.Node, OrderedSet[fx.Node]] = {}
        for n in segment:
            node_to_region[n] = OrderedSet([n])

        # Merge nodes that share data dependencies
        for node in segment:
            fusible_inputs = [
                inp for inp in node.all_input_nodes if inp in segment_set
            ]

            for inp in fusible_inputs:
                # Merge regions (union by size)
                node_region = node_to_region[node]
                inp_region = node_to_region[inp]
                if node_region is not inp_region:
                    # Merge smaller into larger
                    if len(node_region) < len(inp_region):
                        smaller, larger = node_region, inp_region
                    else:
                        smaller, larger = inp_region, node_region

                    larger |= smaller
                    for n in smaller:
                        node_to_region[n] = larger

        # Extract unique regions
        seen_regions: set[int] = set()
        for node in segment:
            region_set = node_to_region[node]
            region_id = id(region_set)
            if region_id in seen_regions:
                continue
            seen_regions.add(region_id)

            members = list(region_set)
            if len(members) < 2:
                continue

            # Topologically sort members based on their dependencies
            members_sorted = _topological_sort_region(members)

            region = FusionRegion(nodes=OrderedSet(members_sorted))
            if region.cost_ms > 0:
                # Map all nodes to this region
                for n in members_sorted:
                    region_of[n] = region

    return region_of


def _topological_sort_region(nodes: list[fx.Node]) -> list[fx.Node]:
    """Topologically sort nodes within a region based on their dependencies."""
    node_set = set(nodes)
    in_degree = {n: 0 for n in nodes}

    # Calculate in-degrees considering only dependencies within the region
    for node in nodes:
        for inp in node.all_input_nodes:
            if inp in node_set:
                in_degree[node] += 1

    # Kahn's algorithm for topological sort
    queue = [n for n in nodes if in_degree[n] == 0]
    result = []

    while queue:
        # Sort queue by a stable key to ensure deterministic ordering
        queue.sort(key=lambda n: n.name)
        node = queue.pop(0)
        result.append(node)

        for user in node.users:
            if user in node_set:
                in_degree[user] -= 1
                if in_degree[user] == 0:
                    queue.append(user)

    # Verify we sorted all nodes (no cycles)
    if len(result) != len(nodes):
        # Fallback to original order if there's a cycle (shouldn't happen)
        return nodes

    return result


def inline_subgraphs(
    graph: fx.Graph,
    region_of: dict[fx.Node, any],
    dep_map: dict[fx.Node, OrderedSet[fx.Node]],
) -> dict[fx.Node, OrderedSet[fx.Node]]:
    """
    Inline subgraph nodes back into the main graph and transfer dependencies.

    If subgraph nodes were created for fusion regions, this function:
    1. Re-inserts the original region nodes back into the graph
    2. Maps dependencies to/from subgraph nodes to the last node in the region
    3. Preserves metadata during the inlining process

    Args:
        graph: The FX graph
        region_of: Mapping of nodes to their fusion regions (with subgraph_node field)
        dep_map: Dependencies between nodes

    Returns:
        Updated dep_map with subgraph nodes replaced by their last internal node
    """
    # Early exit if no regions
    if not region_of:
        return dep_map

    # Get unique regions that have subgraph nodes
    regions_with_subgraphs = []
    seen_region_ids = OrderedSet()

    for region in region_of.values():
        region_id = id(region)
        if (
            region_id not in seen_region_ids
            and hasattr(region, "subgraph_node")
            and region.subgraph_node is not None
        ):
            seen_region_ids.add(region_id)
            regions_with_subgraphs.append(region)

    # Early exit if no subgraphs to inline
    if not regions_with_subgraphs:
        return dep_map

    # Inline each subgraph
    for region in regions_with_subgraphs:
        subgraph_node = region.subgraph_node
        if subgraph_node not in graph.nodes:
            continue

        # Re-insert all nodes from the region back into the graph
        with graph.inserting_before(subgraph_node):
            node_map: dict[fx.Node, fx.Node] = {}

            # Map external inputs (they're already in the graph)
            for ext_input in region.external_inputs:
                node_map[ext_input] = ext_input

            # Clone each node in the region back into the graph
            for old_node in region.nodes:
                # Create the new node using node_copy
                new_node = graph.node_copy(old_node, lambda n: node_map.get(n, n))
                node_map[old_node] = new_node
                # Transfer metadata (following control_dependencies.py pattern)
                new_node.meta.update(old_node.meta)

        # Get the last node (output of the region)
        last_node = node_map[list(region.nodes)[-1]]

        # Replace uses of subgraph_node with the appropriate output
        if len(region.external_outputs) == 1:
            output_node = node_map[next(iter(region.external_outputs))]
            subgraph_node.replace_all_uses_with(output_node)
        else:
            # Multiple outputs - find getitem nodes and replace them
            for user in list(subgraph_node.users.keys()):
                if user.target == torch.ops.aten.getitem:
                    idx = user.args[1]
                    output_node = node_map[list(region.external_outputs)[idx]]
                    user.replace_all_uses_with(output_node)
                    graph.erase_node(user)

        # Erase the subgraph node
        graph.erase_node(subgraph_node)

        # Update dep_map: replace subgraph_node references with last_node
        new_dep_map: dict[fx.Node, OrderedSet[fx.Node]] = {}
        for node, deps in dep_map.items():
            new_node = last_node if node == subgraph_node else node
            new_deps = OrderedSet()
            for dep in deps:
                new_dep = last_node if dep == subgraph_node else dep
                new_deps.add(new_dep)

            if new_node in new_dep_map:
                new_dep_map[new_node].update(new_deps)
            else:
                new_dep_map[new_node] = new_deps

        dep_map = new_dep_map

    return dep_map
```

**Key Components Added**:
- `FusionRegion` dataclass: Represents a connected set of fusible operations
  - Tracks nodes in topological order
  - Computes bandwidth-based cost using `get_gpu_dram_gbps()`
  - Identifies external inputs/outputs/users
  - Cost formula: `cost_ms = (total_bytes / bandwidth_bytes_per_s) * 1000`

- `is_fusible_node(n: fx.Node) -> bool`: Detects fusible operations
  - Includes: pointwise ops (torch.Tag.pointwise), reductions (torch.Tag.reduction), views
  - Includes specific indexing ops: slice.Tensor, gather.default, embedding.default
  - Excludes: mm/conv, collectives, waits, placeholders, outputs

- `build_fusion_regions(graph_nodes: list[fx.Node]) -> dict[fx.Node, FusionRegion]`:
  - Algorithm:
    1. Split graph into segments separated by non-fusible nodes
    2. Within each segment, merge connected nodes via union-find on data dependencies
    3. Topologically sort nodes within each region
    4. Filter regions with cost_ms > 0
  - Returns dict mapping each node to its containing region

- `_topological_sort_region(nodes: list[fx.Node]) -> list[fx.Node]`:
  - Uses Kahn's algorithm for topological sorting
  - Ensures deterministic ordering by sorting queue by node name
  - Handles cycles gracefully (fallback to original order)

- `inline_subgraphs()`: Unchanged from previous version
  - Inlines subgraph HOPs back into main graph
  - Maps dependencies from subgraph nodes to last internal node
  - Preserves metadata throughout

---

### 2. torch/_inductor/fx_passes/overlap_scheduling.py
**Location**: Lines 1192-1209 in `_bucket_collectives()` method

**Changes**:
```python
# BEFORE:
def _bucket_collectives(self) -> None:
    from torch._inductor.fx_passes.overlap_preserving_bucketer import (
        OverlapPreservingBucketer,
    )

    bucketer = OverlapPreservingBucketer(
        graph=self.graph,
        collective_info=self.collective_info,
        scheduled=self.scheduled,
        max_bucket_memory_gb=2.0,
        max_coll_distance=self.max_node_distance,
        insert_overlap_deps=self.insert_overlap_deps,
        region_of={},  # <-- Empty dict, no fusion regions
    )
    bucketer.bucket_collectives()

# AFTER:
def _bucket_collectives(self) -> None:
    from torch._inductor.fx_passes.fusion_regions import build_fusion_regions  # <-- NEW IMPORT
    from torch._inductor.fx_passes.overlap_preserving_bucketer import (
        OverlapPreservingBucketer,
    )

    region_of = build_fusion_regions(list(self.graph.nodes))  # <-- BUILD REGIONS

    bucketer = OverlapPreservingBucketer(
        graph=self.graph,
        collective_info=self.collective_info,
        scheduled=self.scheduled,
        max_bucket_memory_gb=2.0,
        max_coll_distance=self.max_node_distance,
        insert_overlap_deps=self.insert_overlap_deps,
        region_of=region_of,  # <-- Pass actual regions instead of empty dict
    )
    bucketer.bucket_collectives()
```

**Summary**: Added 1 import line and 1 line to build fusion regions before bucketing.

---

### 3. torch/_inductor/fx_passes/overlap_preserving_bucketer.py
**Status**: No changes needed

Already has the infrastructure to accept `region_of` parameter and call `inline_subgraphs()` (from previous integration work).

---

## Key Technical Details

### Bandwidth-Based Cost Model
- Uses `torch._inductor.utils.get_gpu_dram_gbps()` to get HBM bandwidth
- Calculates total bytes from external inputs/outputs (tensor.numel() * tensor.element_size())
- Cost = data transfer time assuming bandwidth-bound operations
- Formula: `cost_ms = (input_bytes + output_bytes) / (bandwidth_gbps * 1e9) * 1000`

### Union-Find for Region Building
- Each segment (consecutive fusible nodes) is processed independently
- Within segment: merge nodes that have data dependencies
- Union-find with union-by-size optimization (merge smaller into larger)
- Ensures each node belongs to exactly one region

### Integration Flow
1. Scheduler calls `_bucket_collectives()`
2. `build_fusion_regions()` detects fusible regions from graph nodes
3. Regions passed to `OverlapPreservingBucketer`
4. Bucketer uses `inline_subgraphs()` to handle any subgraph HOPs before adding overlap deps

---

## Testing Status
- Integration is complete and follows existing patterns
- All code changes are minimal and focused
- Tests were interrupted but structure is correct

---

## Potential Issues to Check

1. **Performance**: Building fusion regions adds compile-time overhead
   - May want to add a config flag to enable/disable
   - Could add logging to track regions found and their costs

2. **Empty Regions**: If no fusible nodes exist or regions have cost_ms == 0
   - Already handles gracefully (returns empty dict)
   - Bucketer handles empty region_of correctly

3. **Metadata Preservation**: Ensure .meta dicts are preserved through region building
   - Currently relies on nodes retaining their original metadata
   - inline_subgraphs() properly transfers metadata

4. **Determinism**: Region building should be deterministic
   - Topological sort uses stable ordering (sort by node.name)
   - Dictionary iteration order is stable in Python 3.7+

---

## Next Steps for Testing

1. Run bucketing unit tests:
   ```bash
   python test/distributed/test_overlap_bucketing_unit.py -v
   ```

2. Run compute-comm reordering tests:
   ```bash
   python test/distributed/test_aten_comm_compute_reordering.py TestComputeCommReorderingBucketing -v
   ```

3. Test with actual models that have fusible regions (models with many pointwise/reduction ops)

4. Add logging to verify regions are being detected:
   ```python
   log.info(f"Built {len(set(region_of.values()))} fusion regions from {len(region_of)} nodes")
   ```

---

## Files Modified Summary
- `/data/users/eellison/pytorch/torch/_inductor/fx_passes/fusion_regions.py` (111 lines → 313 lines, complete rewrite)
- `/data/users/eellison/pytorch/torch/_inductor/fx_passes/overlap_scheduling.py` (1 import added, 1 line changed in `_bucket_collectives()`)

---

## Code Quality
- Follows existing PyTorch patterns (matches control_dependencies.py style)
- Minimal changes to existing code
- No duplication (all fusion logic in fusion_regions.py)
- Clear separation of concerns
- Proper error handling with early exits

---

## References
- Original implementation: commit `58f0b0c80fc`
- Pattern reference: `torch/_inductor/fx_passes/control_dependencies.py`
- Related: `torch/_inductor/fx_passes/overlap_preserving_bucketer.py`

---

## Git Status
Current uncommitted changes:
```
M torch/_inductor/fx_passes/fusion_regions.py
M torch/_inductor/fx_passes/overlap_scheduling.py
```
