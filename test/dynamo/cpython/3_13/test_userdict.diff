diff --git a/test/dynamo/cpython/3_13/test_userdict.py b/test/dynamo/cpython/3_13/test_userdict.py
index 61e79f553e8..cae663b7ecf 100644
--- a/test/dynamo/cpython/3_13/test_userdict.py
+++ b/test/dynamo/cpython/3_13/test_userdict.py
@@ -1,3 +1,57 @@
+# ======= BEGIN Dynamo patch =======
+# Owner(s): ["module: dynamo"]
+
+# ruff: noqa
+# flake8: noqa
+
+# Test copied from
+# https://raw.githubusercontent.com/python/cpython/refs/tags/v3.13.5/Lib/test/test_userdict.py
+
+import sys
+import torch
+import torch._dynamo.test_case
+import unittest
+from torch._dynamo.test_case import CPythonTestCase
+from torch.testing._internal.common_utils import run_tests
+
+__TestCase = CPythonTestCase
+
+
+# redirect import statements
+import sys
+import importlib.abc
+
+redirect_imports = (
+    "test.mapping_tests",
+    "test.typinganndata",
+    "test.test_grammar",
+    "test.test_math",
+    "test.test_iter",
+    "test.typinganndata.ann_module",
+)
+
+class RedirectImportFinder(importlib.abc.MetaPathFinder):
+    def find_spec(self, fullname, path, target=None):
+        # Check if the import is the problematic one
+        if fullname in redirect_imports:
+            try:
+                # Attempt to import the standalone module
+                name = fullname.removeprefix("test.")
+                r = importlib.import_module(name)
+                # Redirect the module in sys.modules
+                sys.modules[fullname] = r
+                # Return a module spec from the found module
+                return importlib.util.find_spec(name)
+            except ImportError:
+                return None
+        return None
+
+# Add the custom finder to sys.meta_path
+sys.meta_path.insert(0, RedirectImportFinder())
+
+
+# ======= END DYNAMO PATCH =======
+
 # Check every path through every method of UserDict
 
 from test import mapping_tests, support
@@ -80,8 +134,9 @@ class UserDictTest(mapping_tests.TestHashMappingProtocol):
         u2c = u2b.copy() # making a copy of a UserDict is special cased
         self.assertEqual(u2b, u2c)
 
-        class MyUserDict(collections.UserDict):
-            def display(self): print(self)
+        with torch._dynamo.error_on_graph_break(False):
+            class MyUserDict(collections.UserDict):
+                def display(self): print(self)
 
         m2 = MyUserDict(u2)
         m2a = m2.copy()
@@ -172,18 +227,20 @@ class UserDictTest(mapping_tests.TestHashMappingProtocol):
         # (E) subclass defines __missing__ method raising RuntimeError
         # (F) subclass sets __missing__ instance variable (no effect)
         # (G) subclass doesn't define __missing__ at all
-        class D(collections.UserDict):
-            def __missing__(self, key):
-                return 42
+        with torch._dynamo.error_on_graph_break(False):
+            class D(collections.UserDict):
+                def __missing__(self, key):
+                    return 42
         d = D({1: 2, 3: 4})
         self.assertEqual(d[1], 2)
         self.assertEqual(d[3], 4)
         self.assertNotIn(2, d)
         self.assertNotIn(2, d.keys())
         self.assertEqual(d[2], 42)
-        class E(collections.UserDict):
-            def __missing__(self, key):
-                raise RuntimeError(key)
+        with torch._dynamo.error_on_graph_break(False):
+            class E(collections.UserDict):
+                def __missing__(self, key):
+                    raise RuntimeError(key)
         e = E()
         try:
             e[42]
@@ -191,11 +248,12 @@ class UserDictTest(mapping_tests.TestHashMappingProtocol):
             self.assertEqual(err.args, (42,))
         else:
             self.fail("e[42] didn't raise RuntimeError")
-        class F(collections.UserDict):
-            def __init__(self):
-                # An instance variable __missing__ should have no effect
-                self.__missing__ = lambda key: None
-                collections.UserDict.__init__(self)
+        with torch._dynamo.error_on_graph_break(False):
+            class F(collections.UserDict):
+                def __init__(self):
+                    # An instance variable __missing__ should have no effect
+                    self.__missing__ = lambda key: None
+                    collections.UserDict.__init__(self)
         f = F()
         try:
             f[42]
@@ -203,8 +261,9 @@ class UserDictTest(mapping_tests.TestHashMappingProtocol):
             self.assertEqual(err.args, (42,))
         else:
             self.fail("f[42] didn't raise KeyError")
-        class G(collections.UserDict):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class G(collections.UserDict):
+                pass
         g = G()
         try:
             g[42]
@@ -215,10 +274,10 @@ class UserDictTest(mapping_tests.TestHashMappingProtocol):
 
     # Decorate existing test with recursion limit, because
     # the test is for C structure, but `UserDict` is a Python structure.
-    test_repr_deep = support.infinite_recursion(25)(
-        mapping_tests.TestHashMappingProtocol.test_repr_deep,
-    )
+    # test_repr_deep = support.infinite_recursion(25)(
+    #     mapping_tests.TestHashMappingProtocol.test_repr_deep,
+    # )
 
 
 if __name__ == "__main__":
-    unittest.main()
+    run_tests()
