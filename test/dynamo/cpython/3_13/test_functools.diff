diff --git a/test/dynamo/cpython/3_13/test_functools.py b/test/dynamo/cpython/3_13/test_functools.py
index 9793df50a3d..63d611ffb15 100644
--- a/test/dynamo/cpython/3_13/test_functools.py
+++ b/test/dynamo/cpython/3_13/test_functools.py
@@ -1,3 +1,22 @@
+# ======= BEGIN Dynamo patch =======
+# Owner(s): ["module: dynamo"]
+
+# ruff: noqa
+# flake8: noqa
+
+# Test copied from
+# https://raw.githubusercontent.com/python/cpython/refs/tags/v3.13.5/Lib/test/test_functools.py
+
+import sys
+import torch
+import torch._dynamo.test_case
+import unittest
+from torch._dynamo.test_case import CPythonTestCase
+from torch.testing._internal.common_utils import run_tests, TEST_WITH_TORCHDYNAMO
+
+# ======= END DYNAMO PATCH =======
+
+
 import abc
 import builtins
 import collections
@@ -61,7 +80,7 @@ class MyDict(dict):
     pass
 
 
-class TestPartial:
+class _TestPartial:
 
     def test_basic_examples(self):
         p = self.partial(capture, 1, 2, a=10, b=20)
@@ -187,12 +206,13 @@ class TestPartial:
 
     def test_nested_optimization_bug(self):
         partial = self.partial
-        class Builder:
-            def __call__(self, tag, *children, **attrib):
-                return (tag, children, attrib)
+        with torch._dynamo.error_on_graph_break(False):
+            class Builder:
+                def __call__(self, tag, *children, **attrib):
+                    return (tag, children, attrib)
 
-            def __getattr__(self, tag):
-                return partial(self, tag)
+                def __getattr__(self, tag):
+                    return partial(self, tag)
 
         B = Builder()
         m = B.m
@@ -380,26 +400,28 @@ class TestPartial:
 
     # Issue 6083: Reference counting bug
     def test_setstate_refcount(self):
-        class BadSequence:
-            def __len__(self):
-                return 4
-            def __getitem__(self, key):
-                if key == 0:
-                    return max
-                elif key == 1:
-                    return tuple(range(1000000))
-                elif key in (2, 3):
-                    return {}
-                raise IndexError
+        with torch._dynamo.error_on_graph_break(False):
+            class BadSequence:
+                def __len__(self):
+                    return 4
+                def __getitem__(self, key):
+                    if key == 0:
+                        return max
+                    elif key == 1:
+                        return tuple(range(1000000))
+                    elif key in (2, 3):
+                        return {}
+                    raise IndexError
 
         f = self.partial(object)
         self.assertRaises(TypeError, f.__setstate__, BadSequence())
 
     def test_partial_as_method(self):
-        class A:
-            meth = self.partial(capture, 1, a=2)
-            cmeth = classmethod(self.partial(capture, 1, a=2))
-            smeth = staticmethod(self.partial(capture, 1, a=2))
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                meth = self.partial(capture, 1, a=2)
+                cmeth = classmethod(self.partial(capture, 1, a=2))
+                smeth = staticmethod(self.partial(capture, 1, a=2))
 
         a = A()
         self.assertEqual(A.meth(3, b=4), ((1, 3), {'a': 2, 'b': 4}))
@@ -419,7 +441,7 @@ class TestPartial:
 
 
 @unittest.skipUnless(c_functools, 'requires the C _functools module')
-class TestPartialC(TestPartial, unittest.TestCase):
+class TestPartialC(_TestPartial, CPythonTestCase):
     if c_functools:
         module = c_functools
         partial = c_functools.partial
@@ -452,10 +474,11 @@ class TestPartialC(TestPartial, unittest.TestCase):
     def test_keystr_replaces_value(self):
         p = self.partial(capture)
 
-        class MutatesYourDict(object):
-            def __str__(self):
-                p.keywords[self] = ['sth2']
-                return 'astr'
+        with torch._dynamo.error_on_graph_break(False):
+            class MutatesYourDict(object):
+                def __str__(self):
+                    p.keywords[self] = ['sth2']
+                    return 'astr'
 
         # Replacing the value during key formatting should keep the original
         # value alive (at least long enough).
@@ -465,7 +488,7 @@ class TestPartialC(TestPartial, unittest.TestCase):
         self.assertIn("['sth']", r)
 
 
-class TestPartialPy(TestPartial, unittest.TestCase):
+class TestPartialPy(_TestPartial, CPythonTestCase):
     module = py_functools
     partial = py_functools.partial
 
@@ -488,7 +511,7 @@ class TestPartialCSubclass(TestPartialC):
 class TestPartialPySubclass(TestPartialPy):
     partial = PyPartialSubclass
 
-class TestPartialMethod(unittest.TestCase):
+class TestPartialMethod(CPythonTestCase):
 
     class A(object):
         nothing = functools.partialmethod(capture)
@@ -604,13 +627,14 @@ class TestPartialMethod(unittest.TestCase):
                          'functools.partialmethod({}, 3, b=4)'.format(capture))
 
     def test_abstract(self):
-        class Abstract(abc.ABCMeta):
+        with torch._dynamo.error_on_graph_break(False):
+            class Abstract(abc.ABCMeta):
 
-            @abc.abstractmethod
-            def add(self, x, y):
-                pass
+                @abc.abstractmethod
+                def add(self, x, y):
+                    pass
 
-            add5 = functools.partialmethod(add, 5)
+                add5 = functools.partialmethod(add, 5)
 
         self.assertTrue(Abstract.add.__isabstractmethod__)
         self.assertTrue(Abstract.add5.__isabstractmethod__)
@@ -626,7 +650,7 @@ class TestPartialMethod(unittest.TestCase):
         self.assertEqual(p(2), f(1, 2))
 
 
-class TestUpdateWrapper(unittest.TestCase):
+class TestUpdateWrapper(CPythonTestCase):
 
     def check_wrapper(self, wrapper, wrapped,
                       assigned=functools.WRAPPER_ASSIGNMENTS,
@@ -812,23 +836,24 @@ class TestWraps(TestUpdateWrapper):
         self.assertEqual(wrapper.dict_attr, f.dict_attr)
 
 
-class TestReduce:
+class _TestReduce:
     def test_reduce(self):
-        class Squares:
-            def __init__(self, max):
-                self.max = max
-                self.sofar = []
-
-            def __len__(self):
-                return len(self.sofar)
-
-            def __getitem__(self, i):
-                if not 0 <= i < self.max: raise IndexError
-                n = len(self.sofar)
-                while n <= i:
-                    self.sofar.append(n*n)
-                    n += 1
-                return self.sofar[i]
+        with torch._dynamo.error_on_graph_break(False):
+            class Squares:
+                def __init__(self, max):
+                    self.max = max
+                    self.sofar = []
+
+                def __len__(self):
+                    return len(self.sofar)
+
+                def __getitem__(self, i):
+                    if not 0 <= i < self.max: raise IndexError
+                    n = len(self.sofar)
+                    while n <= i:
+                        self.sofar.append(n*n)
+                        n += 1
+                    return self.sofar[i]
         def add(x, y):
             return x + y
         self.assertEqual(self.reduce(add, ['a', 'b', 'c'], ''), 'abc')
@@ -844,40 +869,45 @@ class TestReduce:
         self.assertEqual(self.reduce(add, Squares(10)), 285)
         self.assertEqual(self.reduce(add, Squares(10), 0), 285)
         self.assertEqual(self.reduce(add, Squares(0), 0), 0)
-        self.assertRaises(TypeError, self.reduce)
-        self.assertRaises(TypeError, self.reduce, 42, 42)
-        self.assertRaises(TypeError, self.reduce, 42, 42, 42)
+        with torch._dynamo.error_on_graph_break(False):
+            self.assertRaises(TypeError, self.reduce)
+            self.assertRaises(TypeError, self.reduce, 42, 42)
+            self.assertRaises(TypeError, self.reduce, 42, 42, 42)
         self.assertEqual(self.reduce(42, "1"), "1") # func is never called with one item
         self.assertEqual(self.reduce(42, "", "1"), "1") # func is never called with one item
-        self.assertRaises(TypeError, self.reduce, 42, (42, 42))
-        self.assertRaises(TypeError, self.reduce, add, []) # arg 2 must not be empty sequence with no initial value
-        self.assertRaises(TypeError, self.reduce, add, "")
-        self.assertRaises(TypeError, self.reduce, add, ())
-        self.assertRaises(TypeError, self.reduce, add, object())
-
-        class TestFailingIter:
-            def __iter__(self):
-                raise RuntimeError
+        with torch._dynamo.error_on_graph_break(False):
+            self.assertRaises(TypeError, self.reduce, 42, (42, 42))
+            self.assertRaises(TypeError, self.reduce, add, []) # arg 2 must not be empty sequence with no initial value
+            self.assertRaises(TypeError, self.reduce, add, "")
+            self.assertRaises(TypeError, self.reduce, add, ())
+            self.assertRaises(TypeError, self.reduce, add, object())
+
+        with torch._dynamo.error_on_graph_break(False):
+            class TestFailingIter:
+                def __iter__(self):
+                    raise RuntimeError
         self.assertRaises(RuntimeError, self.reduce, add, TestFailingIter())
 
         self.assertEqual(self.reduce(add, [], None), None)
         self.assertEqual(self.reduce(add, [], 42), 42)
 
-        class BadSeq:
-            def __getitem__(self, index):
-                raise ValueError
+        with torch._dynamo.error_on_graph_break(False):
+            class BadSeq:
+                def __getitem__(self, index):
+                    raise ValueError
         self.assertRaises(ValueError, self.reduce, 42, BadSeq())
 
     # Test reduce()'s use of iterators.
     def test_iterator_usage(self):
-        class SequenceClass:
-            def __init__(self, n):
-                self.n = n
-            def __getitem__(self, i):
-                if 0 <= i < self.n:
-                    return i
-                else:
-                    raise IndexError
+        with torch._dynamo.error_on_graph_break(False):
+            class SequenceClass:
+                def __init__(self, n):
+                    self.n = n
+                def __getitem__(self, i):
+                    if 0 <= i < self.n:
+                        return i
+                    else:
+                        raise IndexError
 
         from operator import add
         self.assertEqual(self.reduce(add, SequenceClass(5)), 10)
@@ -892,16 +922,19 @@ class TestReduce:
 
 
 @unittest.skipUnless(c_functools, 'requires the C _functools module')
-class TestReduceC(TestReduce, unittest.TestCase):
+class TestReduceC(_TestReduce, CPythonTestCase):
     if c_functools:
-        reduce = c_functools.reduce
+        if TEST_WITH_TORCHDYNAMO:
+            reduce = functools.reduce
+        else:
+            reduce = c_functools.reduce
 
 
-class TestReducePy(TestReduce, unittest.TestCase):
+class TestReducePy(_TestReduce, CPythonTestCase):
     reduce = staticmethod(py_functools.reduce)
 
 
-class TestCmpToKey:
+class _TestCmpToKey:
 
     def test_cmp_to_key(self):
         def cmp1(x, y):
@@ -946,9 +979,10 @@ class TestCmpToKey:
         with self.assertRaises(ZeroDivisionError):
             key(3) > key(1)
 
-        class BadCmp:
-            def __lt__(self, other):
-                raise ZeroDivisionError
+        with torch._dynamo.error_on_graph_break(False):
+            class BadCmp:
+                def __lt__(self, other):
+                    raise ZeroDivisionError
         def cmp1(x, y):
             return BadCmp()
         with self.assertRaises(ZeroDivisionError):
@@ -996,9 +1030,12 @@ class TestCmpToKey:
 
 
 @unittest.skipUnless(c_functools, 'requires the C _functools module')
-class TestCmpToKeyC(TestCmpToKey, unittest.TestCase):
+class TestCmpToKeyC(_TestCmpToKey, CPythonTestCase):
     if c_functools:
-        cmp_to_key = c_functools.cmp_to_key
+        if TEST_WITH_TORCHDYNAMO:
+            cmp_to_key = functools.cmp_to_key
+        else:
+            cmp_to_key = c_functools.cmp_to_key
 
     @support.cpython_only
     def test_disallow_instantiation(self):
@@ -1008,21 +1045,22 @@ class TestCmpToKeyC(TestCmpToKey, unittest.TestCase):
         )
 
 
-class TestCmpToKeyPy(TestCmpToKey, unittest.TestCase):
+class TestCmpToKeyPy(_TestCmpToKey, CPythonTestCase):
     cmp_to_key = staticmethod(py_functools.cmp_to_key)
 
 
-class TestTotalOrdering(unittest.TestCase):
+class TestTotalOrdering(CPythonTestCase):
 
     def test_total_ordering_lt(self):
-        @functools.total_ordering
-        class A:
-            def __init__(self, value):
-                self.value = value
-            def __lt__(self, other):
-                return self.value < other.value
-            def __eq__(self, other):
-                return self.value == other.value
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class A:
+                def __init__(self, value):
+                    self.value = value
+                def __lt__(self, other):
+                    return self.value < other.value
+                def __eq__(self, other):
+                    return self.value == other.value
         self.assertTrue(A(1) < A(2))
         self.assertTrue(A(2) > A(1))
         self.assertTrue(A(1) <= A(2))
@@ -1032,14 +1070,15 @@ class TestTotalOrdering(unittest.TestCase):
         self.assertFalse(A(1) > A(2))
 
     def test_total_ordering_le(self):
-        @functools.total_ordering
-        class A:
-            def __init__(self, value):
-                self.value = value
-            def __le__(self, other):
-                return self.value <= other.value
-            def __eq__(self, other):
-                return self.value == other.value
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class A:
+                def __init__(self, value):
+                    self.value = value
+                def __le__(self, other):
+                    return self.value <= other.value
+                def __eq__(self, other):
+                    return self.value == other.value
         self.assertTrue(A(1) < A(2))
         self.assertTrue(A(2) > A(1))
         self.assertTrue(A(1) <= A(2))
@@ -1049,14 +1088,15 @@ class TestTotalOrdering(unittest.TestCase):
         self.assertFalse(A(1) >= A(2))
 
     def test_total_ordering_gt(self):
-        @functools.total_ordering
-        class A:
-            def __init__(self, value):
-                self.value = value
-            def __gt__(self, other):
-                return self.value > other.value
-            def __eq__(self, other):
-                return self.value == other.value
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class A:
+                def __init__(self, value):
+                    self.value = value
+                def __gt__(self, other):
+                    return self.value > other.value
+                def __eq__(self, other):
+                    return self.value == other.value
         self.assertTrue(A(1) < A(2))
         self.assertTrue(A(2) > A(1))
         self.assertTrue(A(1) <= A(2))
@@ -1066,14 +1106,15 @@ class TestTotalOrdering(unittest.TestCase):
         self.assertFalse(A(2) < A(1))
 
     def test_total_ordering_ge(self):
-        @functools.total_ordering
-        class A:
-            def __init__(self, value):
-                self.value = value
-            def __ge__(self, other):
-                return self.value >= other.value
-            def __eq__(self, other):
-                return self.value == other.value
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class A:
+                def __init__(self, value):
+                    self.value = value
+                def __ge__(self, other):
+                    return self.value >= other.value
+                def __eq__(self, other):
+                    return self.value == other.value
         self.assertTrue(A(1) < A(2))
         self.assertTrue(A(2) > A(1))
         self.assertTrue(A(1) <= A(2))
@@ -1084,9 +1125,10 @@ class TestTotalOrdering(unittest.TestCase):
 
     def test_total_ordering_no_overwrite(self):
         # new methods should not overwrite existing
-        @functools.total_ordering
-        class A(int):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class A(int):
+                pass
         self.assertTrue(A(1) < A(2))
         self.assertTrue(A(2) > A(1))
         self.assertTrue(A(1) <= A(2))
@@ -1102,57 +1144,58 @@ class TestTotalOrdering(unittest.TestCase):
 
     def test_notimplemented(self):
         # Verify NotImplemented results are correctly handled
-        @functools.total_ordering
-        class ImplementsLessThan:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsLessThan):
-                    return self.value == other.value
-                return False
-            def __lt__(self, other):
-                if isinstance(other, ImplementsLessThan):
-                    return self.value < other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsLessThanEqualTo:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsLessThanEqualTo):
-                    return self.value == other.value
-                return False
-            def __le__(self, other):
-                if isinstance(other, ImplementsLessThanEqualTo):
-                    return self.value <= other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsGreaterThan:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsGreaterThan):
-                    return self.value == other.value
-                return False
-            def __gt__(self, other):
-                if isinstance(other, ImplementsGreaterThan):
-                    return self.value > other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsGreaterThanEqualTo:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsGreaterThanEqualTo):
-                    return self.value == other.value
-                return False
-            def __ge__(self, other):
-                if isinstance(other, ImplementsGreaterThanEqualTo):
-                    return self.value >= other.value
-                return NotImplemented
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class ImplementsLessThan:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsLessThan):
+                        return self.value == other.value
+                    return False
+                def __lt__(self, other):
+                    if isinstance(other, ImplementsLessThan):
+                        return self.value < other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsLessThanEqualTo:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsLessThanEqualTo):
+                        return self.value == other.value
+                    return False
+                def __le__(self, other):
+                    if isinstance(other, ImplementsLessThanEqualTo):
+                        return self.value <= other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsGreaterThan:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsGreaterThan):
+                        return self.value == other.value
+                    return False
+                def __gt__(self, other):
+                    if isinstance(other, ImplementsGreaterThan):
+                        return self.value > other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsGreaterThanEqualTo:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsGreaterThanEqualTo):
+                        return self.value == other.value
+                    return False
+                def __ge__(self, other):
+                    if isinstance(other, ImplementsGreaterThanEqualTo):
+                        return self.value >= other.value
+                    return NotImplemented
 
         self.assertIs(ImplementsLessThan(1).__le__(1), NotImplemented)
         self.assertIs(ImplementsLessThan(1).__gt__(1), NotImplemented)
@@ -1170,68 +1213,69 @@ class TestTotalOrdering(unittest.TestCase):
     def test_type_error_when_not_implemented(self):
         # bug 10042; ensure stack overflow does not occur
         # when decorated types return NotImplemented
-        @functools.total_ordering
-        class ImplementsLessThan:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsLessThan):
-                    return self.value == other.value
-                return False
-            def __lt__(self, other):
-                if isinstance(other, ImplementsLessThan):
-                    return self.value < other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsGreaterThan:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsGreaterThan):
-                    return self.value == other.value
-                return False
-            def __gt__(self, other):
-                if isinstance(other, ImplementsGreaterThan):
-                    return self.value > other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsLessThanEqualTo:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsLessThanEqualTo):
-                    return self.value == other.value
-                return False
-            def __le__(self, other):
-                if isinstance(other, ImplementsLessThanEqualTo):
-                    return self.value <= other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ImplementsGreaterThanEqualTo:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ImplementsGreaterThanEqualTo):
-                    return self.value == other.value
-                return False
-            def __ge__(self, other):
-                if isinstance(other, ImplementsGreaterThanEqualTo):
-                    return self.value >= other.value
-                return NotImplemented
-
-        @functools.total_ordering
-        class ComparatorNotImplemented:
-            def __init__(self, value):
-                self.value = value
-            def __eq__(self, other):
-                if isinstance(other, ComparatorNotImplemented):
-                    return self.value == other.value
-                return False
-            def __lt__(self, other):
-                return NotImplemented
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class ImplementsLessThan:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsLessThan):
+                        return self.value == other.value
+                    return False
+                def __lt__(self, other):
+                    if isinstance(other, ImplementsLessThan):
+                        return self.value < other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsGreaterThan:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsGreaterThan):
+                        return self.value == other.value
+                    return False
+                def __gt__(self, other):
+                    if isinstance(other, ImplementsGreaterThan):
+                        return self.value > other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsLessThanEqualTo:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsLessThanEqualTo):
+                        return self.value == other.value
+                    return False
+                def __le__(self, other):
+                    if isinstance(other, ImplementsLessThanEqualTo):
+                        return self.value <= other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ImplementsGreaterThanEqualTo:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ImplementsGreaterThanEqualTo):
+                        return self.value == other.value
+                    return False
+                def __ge__(self, other):
+                    if isinstance(other, ImplementsGreaterThanEqualTo):
+                        return self.value >= other.value
+                    return NotImplemented
+
+            @functools.total_ordering
+            class ComparatorNotImplemented:
+                def __init__(self, value):
+                    self.value = value
+                def __eq__(self, other):
+                    if isinstance(other, ComparatorNotImplemented):
+                        return self.value == other.value
+                    return False
+                def __lt__(self, other):
+                    return NotImplemented
 
         with self.subTest("LT < 1"), self.assertRaises(TypeError):
             ImplementsLessThan(-1) < 1
@@ -1284,27 +1328,27 @@ class TestTotalOrdering(unittest.TestCase):
 
 
     def test_total_ordering_for_metaclasses_issue_44605(self):
+        with torch._dynamo.error_on_graph_break(False):
+            @functools.total_ordering
+            class SortableMeta(type):
+                def __new__(cls, name, bases, ns):
+                    return super().__new__(cls, name, bases, ns)
 
-        @functools.total_ordering
-        class SortableMeta(type):
-            def __new__(cls, name, bases, ns):
-                return super().__new__(cls, name, bases, ns)
-
-            def __lt__(self, other):
-                if not isinstance(other, SortableMeta):
-                    pass
-                return self.__name__ < other.__name__
+                def __lt__(self, other):
+                    if not isinstance(other, SortableMeta):
+                        pass
+                    return self.__name__ < other.__name__
 
-            def __eq__(self, other):
-                if not isinstance(other, SortableMeta):
-                    pass
-                return self.__name__ == other.__name__
+                def __eq__(self, other):
+                    if not isinstance(other, SortableMeta):
+                        pass
+                    return self.__name__ == other.__name__
 
-        class B(metaclass=SortableMeta):
-            pass
+            class B(metaclass=SortableMeta):
+                pass
 
-        class A(metaclass=SortableMeta):
-            pass
+            class A(metaclass=SortableMeta):
+                pass
 
         self.assertTrue(A < B)
         self.assertFalse(A > B)
@@ -1320,7 +1364,7 @@ class Orderable_LT:
         return self.value == other.value
 
 
-class TestCache:
+class _TestCache:
     # This tests that the pass-through is working as designed.
     # The underlying functionality is tested in TestLRU.
 
@@ -1339,17 +1383,17 @@ class TestCache:
             self.module._CacheInfo(hits=0, misses=0, maxsize=None, currsize=0))
 
 
-class TestCachePy(TestCache, unittest.TestCase):
+class TestCachePy(_TestCache, CPythonTestCase):
     module = py_functools
 
 
 @unittest.skipUnless(c_functools, 'requires the C _functools module')
-class TestCacheC(TestCache, unittest.TestCase):
+class TestCacheC(_TestCache, CPythonTestCase):
     if c_functools:
         module = c_functools
 
 
-class TestLRU:
+class _TestLRUU:
 
     def test_lru(self):
         def orig(x, y):
@@ -1640,8 +1684,9 @@ class TestLRU:
         self.assertEqual(cached((False,)), '(0,)')
         self.assertEqual(cached((0.0,)), '(0,)')
 
-        class T(tuple):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class T(tuple):
+                pass
 
         self.assertEqual(cached(T((1,))), '(1,)')
         self.assertEqual(cached(T((True,))), '(1,)')
@@ -1796,16 +1841,17 @@ class TestLRU:
             'Used to demonstrate a reentrant lru_cache call within a single thread'
             return x
 
-        class DoubleEq:
-            'Demonstrate a reentrant lru_cache call within a single thread'
-            def __init__(self, x):
-                self.x = x
-            def __hash__(self):
-                return self.x
-            def __eq__(self, other):
-                if self.x == 2:
-                    test_func(DoubleEq(1))
-                return self.x == other.x
+        with torch._dynamo.error_on_graph_break(False):
+            class DoubleEq:
+                'Demonstrate a reentrant lru_cache call within a single thread'
+                def __init__(self, x):
+                    self.x = x
+                def __hash__(self):
+                    return self.x
+                def __eq__(self, other):
+                    if self.x == 2:
+                        test_func(DoubleEq(1))
+                    return self.x == other.x
 
         test_func(DoubleEq(1))                      # Load the cache
         test_func(DoubleEq(2))                      # Load the cache
@@ -1813,12 +1859,13 @@ class TestLRU:
                          DoubleEq(2))               # Verify the correct return value
 
     def test_lru_method(self):
-        class X(int):
-            f_cnt = 0
-            @self.module.lru_cache(2)
-            def f(self, x):
-                self.f_cnt += 1
-                return x*10+self
+        with torch._dynamo.error_on_graph_break(False):
+            class X(int):
+                f_cnt = 0
+                @self.module.lru_cache(2)
+                def f(self, x):
+                    self.f_cnt += 1
+                    return x*10+self
         a = X(5)
         b = X(5)
         c = X(7)
@@ -1892,15 +1939,16 @@ class TestLRU:
         def test_function(x):
             return x
 
-        class A:
-            @self.module.lru_cache
-            def test_method(self, x):
-                return (self, x)
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @self.module.lru_cache
+                def test_method(self, x):
+                    return (self, x)
 
-            @staticmethod
-            @self.module.lru_cache
-            def test_staticmethod(x):
-                return (self, x)
+                @staticmethod
+                @self.module.lru_cache
+                def test_staticmethod(x):
+                    return (self, x)
 
         refs = [weakref.ref(test_function),
                 weakref.ref(A.test_method),
@@ -1955,7 +2003,7 @@ if c_functools:
         return 3 * x + y
 
 
-class TestLRUPy(TestLRU, unittest.TestCase):
+class TestLRUPy(_TestLRUU, CPythonTestCase):
     module = py_functools
     cached_func = py_cached_func,
 
@@ -1970,7 +2018,7 @@ class TestLRUPy(TestLRU, unittest.TestCase):
 
 
 @unittest.skipUnless(c_functools, 'requires the C _functools module')
-class TestLRUC(TestLRU, unittest.TestCase):
+class TestLRUC(_TestLRUU, CPythonTestCase):
     if c_functools:
         module = c_functools
         cached_func = c_cached_func,
@@ -1985,7 +2033,7 @@ class TestLRUC(TestLRU, unittest.TestCase):
             return 3 * x + y
 
 
-class TestSingleDispatch(unittest.TestCase):
+class TestSingleDispatch(CPythonTestCase):
     def test_simple_overloads(self):
         @functools.singledispatch
         def g(obj):
@@ -2001,14 +2049,15 @@ class TestSingleDispatch(unittest.TestCase):
         @functools.singledispatch
         def g(obj):
             return "base"
-        class A:
-            pass
-        class C(A):
-            pass
-        class B(A):
-            pass
-        class D(C, B):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                pass
+            class C(A):
+                pass
+            class B(A):
+                pass
+            class D(C, B):
+                pass
         def g_A(a):
             return "A"
         def g_B(b):
@@ -2092,8 +2141,9 @@ class TestSingleDispatch(unittest.TestCase):
         # MutableSequence below is registered directly on D. In other words, it
         # precedes MutableMapping which means single dispatch will always
         # choose MutableSequence here.
-        class D(collections.defaultdict):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class D(collections.defaultdict):
+                pass
         c.MutableSequence.register(D)
         bases = [c.MutableSequence, c.MutableMapping]
         for haystack in permutations(bases):
@@ -2106,9 +2156,10 @@ class TestSingleDispatch(unittest.TestCase):
         # Container and Callable are registered on different base classes and
         # a generic function supporting both should always pick the Callable
         # implementation if a C instance is passed.
-        class C(collections.defaultdict):
-            def __call__(self):
-                pass
+        with torch._dynamo.error_on_graph_break(False):
+            class C(collections.defaultdict):
+                def __call__(self):
+                    pass
         bases = [c.Sized, c.Callable, c.Container, c.Mapping]
         for haystack in permutations(bases):
             m = mro(C, haystack)
@@ -2213,19 +2264,20 @@ class TestSingleDispatch(unittest.TestCase):
     def test_c3_abc(self):
         c = collections.abc
         mro = functools._c3_mro
-        class A(object):
-            pass
-        class B(A):
-            def __len__(self):
-                return 0   # implies Sized
-        @c.Container.register
-        class C(object):
-            pass
-        class D(object):
-            pass   # unrelated
-        class X(D, C, B):
-            def __call__(self):
-                pass   # implies Callable
+        with torch._dynamo.error_on_graph_break(False):
+            class A(object):
+                pass
+            class B(A):
+                def __len__(self):
+                    return 0   # implies Sized
+            @c.Container.register
+            class C(object):
+                pass
+            class D(object):
+                pass   # unrelated
+            class X(D, C, B):
+                def __call__(self):
+                    pass   # implies Callable
         expected = [X, c.Callable, D, C, c.Container, B, c.Sized, A, object]
         for abcs in permutations([c.Sized, c.Callable, c.Container]):
             self.assertEqual(mro(X, abcs=abcs), expected)
@@ -2235,20 +2287,21 @@ class TestSingleDispatch(unittest.TestCase):
 
     def test_false_meta(self):
         # see issue23572
-        class MetaA(type):
-            def __len__(self):
-                return 0
-        class A(metaclass=MetaA):
-            pass
-        class AA(A):
-            pass
-        @functools.singledispatch
-        def fun(a):
-            return 'base A'
-        @fun.register(A)
-        def _(a):
-            return 'fun A'
-        aa = AA()
+        with torch._dynamo.error_on_graph_break(False):
+            class MetaA(type):
+                def __len__(self):
+                    return 0
+            class A(metaclass=MetaA):
+                pass
+            class AA(A):
+                pass
+            @functools.singledispatch
+            def fun(a):
+                return 'base A'
+            @fun.register(A)
+            def _(a):
+                return 'fun A'
+            aa = AA()
         self.assertEqual(fun(aa), 'fun A')
 
     def test_mro_conflicts(self):
@@ -2256,10 +2309,11 @@ class TestSingleDispatch(unittest.TestCase):
         @functools.singledispatch
         def g(arg):
             return "base"
-        class O(c.Sized):
-            def __len__(self):
-                return 0
-        o = O()
+        with torch._dynamo.error_on_graph_break(False):
+            class O(c.Sized):
+                def __len__(self):
+                    return 0
+            o = O()
         self.assertEqual(g(o), "base")
         g.register(c.Iterable, lambda arg: "iterable")
         g.register(c.Container, lambda arg: "container")
@@ -2273,8 +2327,9 @@ class TestSingleDispatch(unittest.TestCase):
         c.Set.register(O)
         self.assertEqual(g(o), "set")     # because c.Set is a subclass of
                                           # c.Sized and c.Container
-        class P:
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class P:
+                pass
         p = P()
         self.assertEqual(g(p), "base")
         c.Iterable.register(P)
@@ -2289,9 +2344,11 @@ class TestSingleDispatch(unittest.TestCase):
              ("Ambiguous dispatch: <class 'collections.abc.Iterable'> "
               "or <class 'collections.abc.Container'>")),
         )
-        class Q(c.Sized):
-            def __len__(self):
-                return 0
+
+        with torch._dynamo.error_on_graph_break(False):
+            class Q(c.Sized):
+                def __len__(self):
+                    return 0
         q = Q()
         self.assertEqual(g(q), "sized")
         c.Iterable.register(Q)
@@ -2321,8 +2378,9 @@ class TestSingleDispatch(unittest.TestCase):
              ("Ambiguous dispatch: <class 'collections.abc.Sized'> "
               "or <class 'collections.abc.Container'>")),
         )
-        class R(collections.defaultdict):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class R(collections.defaultdict):
+                pass
         c.MutableSequence.register(R)
         @functools.singledispatch
         def i(arg):
@@ -2335,18 +2393,20 @@ class TestSingleDispatch(unittest.TestCase):
             return "sequence"
         r = R()
         self.assertEqual(i(r), "sequence")
-        class S:
-            pass
-        class T(S, c.Sized):
-            def __len__(self):
-                return 0
+        with torch._dynamo.error_on_graph_break(False):
+            class S:
+                pass
+            class T(S, c.Sized):
+                def __len__(self):
+                    return 0
         t = T()
         self.assertEqual(h(t), "sized")
         c.Container.register(T)
         self.assertEqual(h(t), "sized")   # because it's explicitly in the MRO
-        class U:
-            def __len__(self):
-                return 0
+        with torch._dynamo.error_on_graph_break(False):
+            class U:
+                def __len__(self):
+                    return 0
         u = U()
         self.assertEqual(h(u), "sized")   # implicit Sized subclass inferred
                                           # from the existence of __len__()
@@ -2361,9 +2421,10 @@ class TestSingleDispatch(unittest.TestCase):
              ("Ambiguous dispatch: <class 'collections.abc.Sized'> "
               "or <class 'collections.abc.Container'>")),
         )
-        class V(c.Sized, S):
-            def __len__(self):
-                return 0
+        with torch._dynamo.error_on_graph_break(False):
+            class V(c.Sized, S):
+                def __len__(self):
+                    return 0
         @functools.singledispatch
         def j(arg):
             return "base"
@@ -2499,27 +2560,29 @@ class TestSingleDispatch(unittest.TestCase):
 
         # Registering classes as callables doesn't work with annotations,
         # you need to pass the type explicitly.
-        @i.register(str)
-        class _:
-            def __init__(self, arg):
-                self.arg = arg
-
-            def __eq__(self, other):
-                return self.arg == other
+        with torch._dynamo.error_on_graph_break(False):
+            @i.register(str)
+            class _:
+                def __init__(self, arg):
+                    self.arg = arg
+
+                def __eq__(self, other):
+                    return self.arg == other
         self.assertEqual(i("str"), "str")
 
     def test_method_register(self):
-        class A:
-            @functools.singledispatchmethod
-            def t(self, arg):
-                self.arg = "base"
-            @t.register(int)
-            def _(self, arg):
-                self.arg = "int"
-            @t.register(str)
-            def _(self, arg):
-                self.arg = "str"
-        a = A()
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def t(self, arg):
+                    self.arg = "base"
+                @t.register(int)
+                def _(self, arg):
+                    self.arg = "int"
+                @t.register(str)
+                def _(self, arg):
+                    self.arg = "str"
+            a = A()
 
         a.t(0)
         self.assertEqual(a.arg, "int")
@@ -2535,72 +2598,76 @@ class TestSingleDispatch(unittest.TestCase):
         self.assertFalse(hasattr(aa, 'arg'))
 
     def test_staticmethod_register(self):
-        class A:
-            @functools.singledispatchmethod
-            @staticmethod
-            def t(arg):
-                return arg
-            @t.register(int)
-            @staticmethod
-            def _(arg):
-                return isinstance(arg, int)
-            @t.register(str)
-            @staticmethod
-            def _(arg):
-                return isinstance(arg, str)
-        a = A()
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                @staticmethod
+                def t(arg):
+                    return arg
+                @t.register(int)
+                @staticmethod
+                def _(arg):
+                    return isinstance(arg, int)
+                @t.register(str)
+                @staticmethod
+                def _(arg):
+                    return isinstance(arg, str)
+            a = A()
 
         self.assertTrue(A.t(0))
         self.assertTrue(A.t(''))
         self.assertEqual(A.t(0.0), 0.0)
 
     def test_slotted_class(self):
-        class Slot:
-            __slots__ = ('a', 'b')
-            @functools.singledispatchmethod
-            def go(self, item, arg):
-                pass
+        with torch._dynamo.error_on_graph_break(False):
+            class Slot:
+                __slots__ = ('a', 'b')
+                @functools.singledispatchmethod
+                def go(self, item, arg):
+                    pass
 
-            @go.register
-            def _(self, item: int, arg):
-                return item + arg
+                @go.register
+                def _(self, item: int, arg):
+                    return item + arg
 
-        s = Slot()
+            s = Slot()
         self.assertEqual(s.go(1, 1), 2)
 
     def test_classmethod_slotted_class(self):
-        class Slot:
-            __slots__ = ('a', 'b')
-            @functools.singledispatchmethod
-            @classmethod
-            def go(cls, item, arg):
-                pass
+        with torch._dynamo.error_on_graph_break(False):
+            class Slot:
+                __slots__ = ('a', 'b')
+                @functools.singledispatchmethod
+                @classmethod
+                def go(cls, item, arg):
+                    pass
 
-            @go.register
-            @classmethod
-            def _(cls, item: int, arg):
-                return item + arg
+                @go.register
+                @classmethod
+                def _(cls, item: int, arg):
+                    return item + arg
 
-        s = Slot()
+            s = Slot()
         self.assertEqual(s.go(1, 1), 2)
         self.assertEqual(Slot.go(1, 1), 2)
 
     def test_staticmethod_slotted_class(self):
-        class A:
-            __slots__ = ['a']
-            @functools.singledispatchmethod
-            @staticmethod
-            def t(arg):
-                return arg
-            @t.register(int)
-            @staticmethod
-            def _(arg):
-                return isinstance(arg, int)
-            @t.register(str)
-            @staticmethod
-            def _(arg):
-                return isinstance(arg, str)
-        a = A()
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                __slots__ = ['a']
+                @functools.singledispatchmethod
+                @staticmethod
+                def t(arg):
+                    return arg
+                @t.register(int)
+                @staticmethod
+                def _(arg):
+                    return isinstance(arg, int)
+                @t.register(str)
+                @staticmethod
+                def _(arg):
+                    return isinstance(arg, str)
+            a = A()
 
         self.assertTrue(A.t(0))
         self.assertTrue(A.t(''))
@@ -2611,10 +2678,11 @@ class TestSingleDispatch(unittest.TestCase):
 
     def test_assignment_behavior(self):
         # see gh-106448
-        class A:
-            @functools.singledispatchmethod
-            def t(arg):
-                return arg
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def t(arg):
+                    return arg
 
         a = A()
         a.t.foo = 'bar'
@@ -2623,36 +2691,38 @@ class TestSingleDispatch(unittest.TestCase):
             a2.t.foo
 
     def test_classmethod_register(self):
-        class A:
-            def __init__(self, arg):
-                self.arg = arg
-
-            @functools.singledispatchmethod
-            @classmethod
-            def t(cls, arg):
-                return cls("base")
-            @t.register(int)
-            @classmethod
-            def _(cls, arg):
-                return cls("int")
-            @t.register(str)
-            @classmethod
-            def _(cls, arg):
-                return cls("str")
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def __init__(self, arg):
+                    self.arg = arg
+
+                @functools.singledispatchmethod
+                @classmethod
+                def t(cls, arg):
+                    return cls("base")
+                @t.register(int)
+                @classmethod
+                def _(cls, arg):
+                    return cls("int")
+                @t.register(str)
+                @classmethod
+                def _(cls, arg):
+                    return cls("str")
 
         self.assertEqual(A.t(0).arg, "int")
         self.assertEqual(A.t('').arg, "str")
         self.assertEqual(A.t(0.0).arg, "base")
 
     def test_callable_register(self):
-        class A:
-            def __init__(self, arg):
-                self.arg = arg
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def __init__(self, arg):
+                    self.arg = arg
 
-            @functools.singledispatchmethod
-            @classmethod
-            def t(cls, arg):
-                return cls("base")
+                @functools.singledispatchmethod
+                @classmethod
+                def t(cls, arg):
+                    return cls("base")
 
         @A.t.register(int)
         @classmethod
@@ -2668,12 +2738,13 @@ class TestSingleDispatch(unittest.TestCase):
         self.assertEqual(A.t(0.0).arg, "base")
 
     def test_abstractmethod_register(self):
-        class Abstract(metaclass=abc.ABCMeta):
+        with torch._dynamo.error_on_graph_break(False):
+            class Abstract(metaclass=abc.ABCMeta):
 
-            @functools.singledispatchmethod
-            @abc.abstractmethod
-            def add(self, x, y):
-                pass
+                @functools.singledispatchmethod
+                @abc.abstractmethod
+                def add(self, x, y):
+                    pass
 
         self.assertTrue(Abstract.add.__isabstractmethod__)
         self.assertTrue(Abstract.__dict__['add'].__isabstractmethod__)
@@ -2682,80 +2753,84 @@ class TestSingleDispatch(unittest.TestCase):
             Abstract()
 
     def test_type_ann_register(self):
-        class A:
-            @functools.singledispatchmethod
-            def t(self, arg):
-                return "base"
-            @t.register
-            def _(self, arg: int):
-                return "int"
-            @t.register
-            def _(self, arg: str):
-                return "str"
-        a = A()
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def t(self, arg):
+                    return "base"
+                @t.register
+                def _(self, arg: int):
+                    return "int"
+                @t.register
+                def _(self, arg: str):
+                    return "str"
+            a = A()
 
         self.assertEqual(a.t(0), "int")
         self.assertEqual(a.t(''), "str")
         self.assertEqual(a.t(0.0), "base")
 
     def test_staticmethod_type_ann_register(self):
-        class A:
-            @functools.singledispatchmethod
-            @staticmethod
-            def t(arg):
-                return arg
-            @t.register
-            @staticmethod
-            def _(arg: int):
-                return isinstance(arg, int)
-            @t.register
-            @staticmethod
-            def _(arg: str):
-                return isinstance(arg, str)
-        a = A()
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                @staticmethod
+                def t(arg):
+                    return arg
+                @t.register
+                @staticmethod
+                def _(arg: int):
+                    return isinstance(arg, int)
+                @t.register
+                @staticmethod
+                def _(arg: str):
+                    return isinstance(arg, str)
+            a = A()
 
         self.assertTrue(A.t(0))
         self.assertTrue(A.t(''))
         self.assertEqual(A.t(0.0), 0.0)
 
     def test_classmethod_type_ann_register(self):
-        class A:
-            def __init__(self, arg):
-                self.arg = arg
-
-            @functools.singledispatchmethod
-            @classmethod
-            def t(cls, arg):
-                return cls("base")
-            @t.register
-            @classmethod
-            def _(cls, arg: int):
-                return cls("int")
-            @t.register
-            @classmethod
-            def _(cls, arg: str):
-                return cls("str")
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def __init__(self, arg):
+                    self.arg = arg
+
+                @functools.singledispatchmethod
+                @classmethod
+                def t(cls, arg):
+                    return cls("base")
+                @t.register
+                @classmethod
+                def _(cls, arg: int):
+                    return cls("int")
+                @t.register
+                @classmethod
+                def _(cls, arg: str):
+                    return cls("str")
 
         self.assertEqual(A.t(0).arg, "int")
         self.assertEqual(A.t('').arg, "str")
         self.assertEqual(A.t(0.0).arg, "base")
 
     def test_method_wrapping_attributes(self):
-        class A:
-            @functools.singledispatchmethod
-            def func(self, arg: int) -> str:
-                """My function docstring"""
-                return str(arg)
-            @functools.singledispatchmethod
-            @classmethod
-            def cls_func(cls, arg: int) -> str:
-                """My function docstring"""
-                return str(arg)
-            @functools.singledispatchmethod
-            @staticmethod
-            def static_func(arg: int) -> str:
-                """My function docstring"""
-                return str(arg)
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def func(self, arg: int) -> str:
+                    """My function docstring"""
+                    return str(arg)
+                @functools.singledispatchmethod
+                @classmethod
+                def cls_func(cls, arg: int) -> str:
+                    """My function docstring"""
+                    return str(arg)
+                @functools.singledispatchmethod
+                @staticmethod
+                def static_func(arg: int) -> str:
+                    """My function docstring"""
+                    return str(arg)
 
         prefix = A.__qualname__ + '.'
         for meth in (
@@ -2790,37 +2865,38 @@ class TestSingleDispatch(unittest.TestCase):
                 return wrapped(*args, **kwargs)
             return wrapper
 
-        class WithoutSingleDispatch:
-            @classmethod
-            @contextlib.contextmanager
-            def cls_context_manager(cls, arg: int) -> str:
-                try:
-                    yield str(arg)
-                finally:
-                    return 'Done'
-
-            @classmethod_friendly_decorator
-            @classmethod
-            def decorated_classmethod(cls, arg: int) -> str:
-                return str(arg)
+        with torch._dynamo.error_on_graph_break(False):
+            class WithoutSingleDispatch:
+                @classmethod
+                @contextlib.contextmanager
+                def cls_context_manager(cls, arg: int) -> str:
+                    try:
+                        yield str(arg)
+                    finally:
+                        return 'Done'
+
+                @classmethod_friendly_decorator
+                @classmethod
+                def decorated_classmethod(cls, arg: int) -> str:
+                    return str(arg)
+
+            class WithSingleDispatch:
+                @functools.singledispatchmethod
+                @classmethod
+                @contextlib.contextmanager
+                def cls_context_manager(cls, arg: int) -> str:
+                    """My function docstring"""
+                    try:
+                        yield str(arg)
+                    finally:
+                        return 'Done'
 
-        class WithSingleDispatch:
-            @functools.singledispatchmethod
-            @classmethod
-            @contextlib.contextmanager
-            def cls_context_manager(cls, arg: int) -> str:
-                """My function docstring"""
-                try:
-                    yield str(arg)
-                finally:
-                    return 'Done'
-
-            @functools.singledispatchmethod
-            @classmethod_friendly_decorator
-            @classmethod
-            def decorated_classmethod(cls, arg: int) -> str:
-                """My function docstring"""
-                return str(arg)
+                @functools.singledispatchmethod
+                @classmethod_friendly_decorator
+                @classmethod
+                def decorated_classmethod(cls, arg: int) -> str:
+                    """My function docstring"""
+                    return str(arg)
 
         # These are sanity checks
         # to test the test itself is working as expected
@@ -2945,10 +3021,11 @@ class TestSingleDispatch(unittest.TestCase):
             f(a=1)
 
     def test_invalid_positional_argument_singledispatchmethod(self):
-        class A:
-            @functools.singledispatchmethod
-            def t(self, *args, **kwargs):
-                pass
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def t(self, *args, **kwargs):
+                    pass
         msg = 't requires at least 1 positional argument'
         with self.assertRaisesRegex(TypeError, msg):
             A().t()
@@ -3080,14 +3157,15 @@ class TestSingleDispatch(unittest.TestCase):
 
     def test_method_equal_instances(self):
         # gh-127750: Reference to self was cached
-        class A:
-            def __eq__(self, other):
-                return True
-            def __hash__(self):
-                return 1
-            @functools.singledispatchmethod
-            def t(self, arg):
-                return self
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def __eq__(self, other):
+                    return True
+                def __hash__(self):
+                    return 1
+                @functools.singledispatchmethod
+                def t(self, arg):
+                    return self
 
         a = A()
         b = A()
@@ -3095,14 +3173,15 @@ class TestSingleDispatch(unittest.TestCase):
         self.assertIs(b.t(2), b)
 
     def test_method_bad_hash(self):
-        class A:
-            def __eq__(self, other):
-                raise AssertionError
-            def __hash__(self):
-                raise AssertionError
-            @functools.singledispatchmethod
-            def t(self, arg):
-                pass
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def __eq__(self, other):
+                    raise AssertionError
+                def __hash__(self):
+                    raise AssertionError
+                @functools.singledispatchmethod
+                def t(self, arg):
+                    pass
 
         # Should not raise
         A().t(1)
@@ -3111,10 +3190,11 @@ class TestSingleDispatch(unittest.TestCase):
 
     def test_method_no_reference_loops(self):
         # gh-127750: Created a strong reference to self
-        class A:
-            @functools.singledispatchmethod
-            def t(self, arg):
-                return weakref.ref(self)
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                @functools.singledispatchmethod
+                def t(self, arg):
+                    return weakref.ref(self)
 
         a = A()
         r = a.t(1)
@@ -3147,36 +3227,37 @@ class TestSingleDispatch(unittest.TestCase):
                          '(item, arg: int) -> str')
 
     def test_method_signatures(self):
-        class A:
-            def m(self, item, arg: int) -> str:
-                return str(item)
-            @classmethod
-            def cm(cls, item, arg: int) -> str:
-                return str(item)
-            @functools.singledispatchmethod
-            def func(self, item, arg: int) -> str:
-                return str(item)
-            @func.register
-            def _(self, item, arg: bytes) -> str:
-                return str(item)
-
-            @functools.singledispatchmethod
-            @classmethod
-            def cls_func(cls, item, arg: int) -> str:
-                return str(arg)
-            @func.register
-            @classmethod
-            def _(cls, item, arg: bytes) -> str:
-                return str(item)
-
-            @functools.singledispatchmethod
-            @staticmethod
-            def static_func(item, arg: int) -> str:
-                return str(arg)
-            @func.register
-            @staticmethod
-            def _(item, arg: bytes) -> str:
-                return str(item)
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                def m(self, item, arg: int) -> str:
+                    return str(item)
+                @classmethod
+                def cm(cls, item, arg: int) -> str:
+                    return str(item)
+                @functools.singledispatchmethod
+                def func(self, item, arg: int) -> str:
+                    return str(item)
+                @func.register
+                def _(self, item, arg: bytes) -> str:
+                    return str(item)
+
+                @functools.singledispatchmethod
+                @classmethod
+                def cls_func(cls, item, arg: int) -> str:
+                    return str(arg)
+                @func.register
+                @classmethod
+                def _(cls, item, arg: bytes) -> str:
+                    return str(item)
+
+                @functools.singledispatchmethod
+                @staticmethod
+                def static_func(item, arg: int) -> str:
+                    return str(arg)
+                @func.register
+                @staticmethod
+                def _(item, arg: bytes) -> str:
+                    return str(item)
 
         self.assertEqual(str(Signature.from_callable(A.func)),
                          '(self, item, arg: int) -> str')
@@ -3224,7 +3305,7 @@ class CachedCostItemWithSlots:
         raise RuntimeError('never called, slots not supported')
 
 
-class TestCachedProperty(unittest.TestCase):
+class TestCachedProperty(CPythonTestCase):
     def test_cached(self):
         item = CachedCostItem()
         self.assertEqual(item.cost, 2)
@@ -3246,13 +3327,14 @@ class TestCachedProperty(unittest.TestCase):
             item.cost
 
     def test_immutable_dict(self):
-        class MyMeta(type):
-            @py_functools.cached_property
-            def prop(self):
-                return True
+        with torch._dynamo.error_on_graph_break(False):
+            class MyMeta(type):
+                @py_functools.cached_property
+                def prop(self):
+                    return True
 
-        class MyClass(metaclass=MyMeta):
-            pass
+            class MyClass(metaclass=MyMeta):
+                pass
 
         with self.assertRaisesRegex(
             TypeError,
@@ -3285,11 +3367,12 @@ class TestCachedProperty(unittest.TestCase):
             counter += 1
             return counter
 
-        class A:
-            cp = _cp
+        with torch._dynamo.error_on_graph_break(False):
+            class A:
+                cp = _cp
 
-        class B:
-            cp = _cp
+            class B:
+                cp = _cp
 
         a = A()
         b = B()
@@ -3300,8 +3383,9 @@ class TestCachedProperty(unittest.TestCase):
 
     def test_set_name_not_called(self):
         cp = py_functools.cached_property(lambda s: None)
-        class Foo:
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class Foo:
+                pass
 
         Foo.cp = cp
 
@@ -3325,17 +3409,18 @@ class TestCachedProperty(unittest.TestCase):
 
     def test_subclass_with___set__(self):
         """Caching still works for a subclass defining __set__."""
-        class readonly_cached_property(py_functools.cached_property):
-            def __set__(self, obj, value):
-                raise AttributeError("read only property")
+        with torch._dynamo.error_on_graph_break(False):
+            class readonly_cached_property(py_functools.cached_property):
+                def __set__(self, obj, value):
+                    raise AttributeError("read only property")
 
-        class Test:
-            def __init__(self, prop):
-                self._prop = prop
+            class Test:
+                def __init__(self, prop):
+                    self._prop = prop
 
-            @readonly_cached_property
-            def prop(self):
-                return self._prop
+                @readonly_cached_property
+                def prop(self):
+                    return self._prop
 
         t = Test(1)
         self.assertEqual(t.prop, 1)
@@ -3344,4 +3429,4 @@ class TestCachedProperty(unittest.TestCase):
 
 
 if __name__ == '__main__':
-    unittest.main()
+    run_tests()
