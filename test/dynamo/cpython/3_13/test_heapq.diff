diff --git a/test/dynamo/cpython/3_13/test_heapq.py b/test/dynamo/cpython/3_13/test_heapq.py
index 1aa8e4e2897..bc177c2943e 100644
--- a/test/dynamo/cpython/3_13/test_heapq.py
+++ b/test/dynamo/cpython/3_13/test_heapq.py
@@ -1,3 +1,23 @@
+# ======= BEGIN Dynamo patch =======
+# Owner(s): ["module: dynamo"]
+
+# ruff: noqa
+# flake8: noqa
+
+# Test copied from
+# https://raw.githubusercontent.com/python/cpython/refs/tags/v3.13.5/Lib/test/test_collections.py
+
+import sys
+import torch
+import torch._dynamo.test_case
+import unittest
+from torch._dynamo.test_case import CPythonTestCase
+from torch.testing._internal.common_utils import run_tests
+
+__TestCase = CPythonTestCase
+
+# ======= END DYNAMO PATCH =======
+
 """Unittests for heapq."""
 
 import random
@@ -16,7 +36,7 @@ c_heapq = import_helper.import_fresh_module('heapq', fresh=['_heapq'])
 func_names = ['heapify', 'heappop', 'heappush', 'heappushpop', 'heapreplace',
               '_heappop_max', '_heapreplace_max', '_heapify_max']
 
-class TestModules(TestCase):
+class TestModules(__TestCase):
     def test_py_functions(self):
         for fname in func_names:
             self.assertEqual(getattr(py_heapq, fname).__module__, 'heapq')
@@ -27,24 +47,12 @@ class TestModules(TestCase):
             self.assertEqual(getattr(c_heapq, fname).__module__, '_heapq')
 
 
-def load_tests(loader, tests, ignore):
-    # The 'merge' function has examples in its docstring which we should test
-    # with 'doctest'.
-    #
-    # However, doctest can't easily find all docstrings in the module (loading
-    # it through import_fresh_module seems to confuse it), so we specifically
-    # create a finder which returns the doctests from the merge method.
+@torch._dynamo.disable
+def randrange(*args):
+    return random.randrange(*args)
 
-    class HeapqMergeDocTestFinder:
-        def find(self, *args, **kwargs):
-            dtf = doctest.DocTestFinder()
-            return dtf.find(py_heapq.merge)
 
-    tests.addTests(doctest.DocTestSuite(py_heapq,
-                                        test_finder=HeapqMergeDocTestFinder()))
-    return tests
-
-class TestHeap:
+class _TestHeap:
 
     def test_push_pop(self):
         # 1) Push 256 random numbers and pop them off, verifying all's OK.
@@ -52,7 +60,8 @@ class TestHeap:
         data = []
         self.check_invariant(heap)
         for i in range(256):
-            item = random.random()
+            with torch._dynamo.error_on_graph_break(False):
+                item = random.random()
             data.append(item)
             self.module.heappush(heap, item)
             self.check_invariant(heap)
@@ -83,14 +92,16 @@ class TestHeap:
 
     def test_heapify(self):
         for size in list(range(30)) + [20000]:
-            heap = [random.random() for dummy in range(size)]
+            with torch._dynamo.error_on_graph_break(False):
+                heap = [random.random() for dummy in range(size)]
             self.module.heapify(heap)
             self.check_invariant(heap)
 
         self.assertRaises(TypeError, self.module.heapify, None)
 
     def test_naive_nbest(self):
-        data = [random.randrange(2000) for i in range(1000)]
+        with torch._dynamo.error_on_graph_break(False):
+            data = [randrange(2000) for i in range(1000)]
         heap = []
         for item in data:
             self.module.heappush(heap, item)
@@ -113,7 +124,8 @@ class TestHeap:
         # heap instead of a min heap, it could go faster still via
         # heapify'ing all of data (linear time), then doing 10 heappops
         # (10 log-time steps).
-        data = [random.randrange(2000) for i in range(1000)]
+        with torch._dynamo.error_on_graph_break(False):
+            data = [randrange(2000) for i in range(1000)]
         heap = data[:10]
         self.module.heapify(heap)
         for item in data[10:]:
@@ -126,7 +138,8 @@ class TestHeap:
         self.assertRaises(IndexError, self.module.heapreplace, [], None)
 
     def test_nbest_with_pushpop(self):
-        data = [random.randrange(2000) for i in range(1000)]
+        with torch._dynamo.error_on_graph_break(False):
+            data = [randrange(2000) for i in range(1000)]
         heap = data[:10]
         self.module.heapify(heap)
         for item in data[10:]:
@@ -163,8 +176,9 @@ class TestHeap:
     def test_heapsort(self):
         # Exercise everything with repeated heapsort checks
         for trial in range(100):
-            size = random.randrange(50)
-            data = [random.randrange(25) for i in range(size)]
+            with torch._dynamo.error_on_graph_break(False):
+                size = randrange(50)
+                data = [randrange(25) for i in range(size)]
             if trial & 1:     # Half of the time, use heapify
                 heap = data[:]
                 self.module.heapify(heap)
@@ -177,12 +191,13 @@ class TestHeap:
 
     def test_merge(self):
         inputs = []
-        for i in range(random.randrange(25)):
-            row = []
-            for j in range(random.randrange(100)):
-                tup = random.choice('ABC'), random.randrange(-500, 500)
-                row.append(tup)
-            inputs.append(row)
+        with torch._dynamo.error_on_graph_break(False):
+            for i in range(randrange(25)):
+                row = []
+                for j in range(randrange(100)):
+                    tup = random.choice('ABC'), randrange(-500, 500)
+                    row.append(tup)
+                inputs.append(row)
 
         for key in [None, itemgetter(0), itemgetter(1), itemgetter(1, 0)]:
             for reverse in [False, True]:
@@ -209,12 +224,14 @@ class TestHeap:
             list(self.module.merge(iterable(), iterable()))
 
     def test_merge_stability(self):
-        class Int(int):
-            pass
+        with torch._dynamo.error_on_graph_break(False):
+            class Int(int):
+                pass
         inputs = [[], [], [], []]
         for i in range(20000):
-            stream = random.randrange(4)
-            x = random.randrange(500)
+            with torch._dynamo.error_on_graph_break(False):
+                stream = randrange(4)
+                x = randrange(500)
             obj = Int(x)
             obj.pair = (x, stream)
             inputs[stream].append(obj)
@@ -224,7 +241,8 @@ class TestHeap:
         self.assertEqual(result, sorted(result))
 
     def test_nsmallest(self):
-        data = [(random.randrange(2000), i) for i in range(1000)]
+        with torch._dynamo.error_on_graph_break(False):
+            data = [(randrange(2000), i) for i in range(1000)]
         for f in (None, lambda x:  x[0] * 547 % 2000):
             for n in (0, 1, 2, 10, 100, 400, 999, 1000, 1100):
                 self.assertEqual(list(self.module.nsmallest(n, data)),
@@ -233,7 +251,8 @@ class TestHeap:
                                  sorted(data, key=f)[:n])
 
     def test_nlargest(self):
-        data = [(random.randrange(2000), i) for i in range(1000)]
+        with torch._dynamo.error_on_graph_break(False):
+            data = [(randrange(2000), i) for i in range(1000)]
         for f in (None, lambda x:  x[0] * 547 % 2000):
             for n in (0, 1, 2, 10, 100, 400, 999, 1000, 1100):
                 self.assertEqual(list(self.module.nlargest(n, data)),
@@ -248,28 +267,29 @@ class TestHeap:
             data = [comp(x) for x in data]
             self.module.heapify(data)
             return [self.module.heappop(data).x for i in range(len(data))]
-        class LT:
-            def __init__(self, x):
-                self.x = x
-            def __lt__(self, other):
-                return self.x > other.x
-        class LE:
-            def __init__(self, x):
-                self.x = x
-            def __le__(self, other):
-                return self.x >= other.x
-        data = [random.random() for i in range(100)]
+        with torch._dynamo.error_on_graph_break(False):
+            class LT:
+                def __init__(self, x):
+                    self.x = x
+                def __lt__(self, other):
+                    return self.x > other.x
+            class LE:
+                def __init__(self, x):
+                    self.x = x
+                def __le__(self, other):
+                    return self.x >= other.x
+            data = [random.random() for i in range(100)]
         target = sorted(data, reverse=True)
         self.assertEqual(hsort(data, LT), target)
         self.assertRaises(TypeError, data, LE)
 
 
-class TestHeapPython(TestHeap, TestCase):
+class TestHeapPython(_TestHeap, __TestCase):
     module = py_heapq
 
 
 @skipUnless(c_heapq, 'requires _heapq')
-class TestHeapC(TestHeap, TestCase):
+class TestHeapC(_TestHeap, __TestCase):
     module = c_heapq
 
 
@@ -374,7 +394,7 @@ class SideEffectLT:
         return self.value < other.value
 
 
-class TestErrorHandling:
+class _TestErrorHandling:
 
     def test_non_sequence(self):
         for f in (self.module.heapify, self.module.heappop):
@@ -435,10 +455,11 @@ class TestErrorHandling:
     def test_comparison_operator_modifiying_heap(self):
         # See bpo-39421: Strong references need to be taken
         # when comparing objects as they can alter the heap
-        class EvilClass(int):
-            def __lt__(self, o):
-                heap.clear()
-                return NotImplemented
+        with torch._dynamo.error_on_graph_break(False):
+            class EvilClass(int):
+                def __lt__(self, o):
+                    heap.clear()
+                    return NotImplemented
 
         heap = []
         self.module.heappush(heap, EvilClass(0))
@@ -446,15 +467,16 @@ class TestErrorHandling:
 
     def test_comparison_operator_modifiying_heap_two_heaps(self):
 
-        class h(int):
-            def __lt__(self, o):
-                list2.clear()
-                return NotImplemented
+        with torch._dynamo.error_on_graph_break(False):
+            class h(int):
+                def __lt__(self, o):
+                    list2.clear()
+                    return NotImplemented
 
-        class g(int):
-            def __lt__(self, o):
-                list1.clear()
-                return NotImplemented
+            class g(int):
+                def __lt__(self, o):
+                    list1.clear()
+                    return NotImplemented
 
         list1, list2 = [], []
 
@@ -464,13 +486,13 @@ class TestErrorHandling:
         self.assertRaises((IndexError, RuntimeError), self.module.heappush, list1, g(1))
         self.assertRaises((IndexError, RuntimeError), self.module.heappush, list2, h(1))
 
-class TestErrorHandlingPython(TestErrorHandling, TestCase):
+class TestErrorHandlingPython(_TestErrorHandling, __TestCase):
     module = py_heapq
 
 @skipUnless(c_heapq, 'requires _heapq')
-class TestErrorHandlingC(TestErrorHandling, TestCase):
+class TestErrorHandlingC(_TestErrorHandling, __TestCase):
     module = c_heapq
 
 
 if __name__ == "__main__":
-    unittest.main()
+    run_tests()
