#include <ATen/mklrng/MKLGeneratorImpl.h>
#include <ATen/Utils.h>
#include <cstdint>

namespace at {
namespace detail {

/**
 * PyTorch maintains a collection of default generators that get
 * initialized once. The purpose of these default generators is to
 * maintain a global running state of the pseudo random number generation,
 * when a user does not explicitly mention any generator.
 * getDefaultMKLGenerator gets the default generator for a particular
 * device.
 */
const Generator& getDefaultMKLGenerator() {
  static auto gen = createMKLGenerator(c10::detail::getNonDeterministicRandom());
  return gen;
}

/**
 * Utility to create an MKLGeneratorImpl. Returns a shared_ptr
 */
Generator createMKLGenerator(uint64_t seed_val) {
  return make_generator<MKLGeneratorImpl>(seed_val);
}

} // namespace detail

/**
 * MKLGeneratorImpl class implementation
 */
MKLGeneratorImpl::MKLGeneratorImpl(uint64_t seed_in)
  : c10::GeneratorImpl{Device(DeviceType::CPU), DispatchKeySet(c10::DispatchKey::CPU)},
    seed_(seed_in),
    offset_(0) {
    vslNewStream(&stream_, VSL_BRNG_PHILOX4X32X10, seed_);
  }

/**
 * Manually seeds the engine with the seed input
 * See Note [Acquire lock when using random generators]
 */
void MKLGeneratorImpl::set_current_seed(uint64_t seed) {
  this->seed_ = seed;
  vslDeleteStream(&stream_);
  vslNewStream(&stream_, VSL_BRNG_PHILOX4X32X10, seed_);
  this->offset_ = 0;
}

/**
 * Gets a nondeterministic random number from /dev/urandom or time,
 * seeds the MKLGeneratorImpl with it and then returns that number.
 * See Note [Acquire lock when using random generators]
 */
uint64_t MKLGeneratorImpl::seed() {
  auto random = c10::detail::getNonDeterministicRandom();
  this->set_current_seed(static_cast<uint64_t>(random));
  return random;
}

/**
 * Gets the current seed of CPUGeneratorImpl.
 */
uint64_t MKLGeneratorImpl::current_seed() const {
  return this->seed_;
}

/**
 * Gets the DeviceType of MKLGeneratorImpl.
 * Used for type checking during run time.
 */
DeviceType MKLGeneratorImpl::device_type() {
  return DeviceType::CPU;
}

/**
 * Gets the copy of VSLStreamStatePtr in MKLGenerator
 * to be used for variate generation in a thread-safe way
 * (each thread should receive its own stream copy).
 * See Note [Acquire lock when using random generators]
 */
void MKLGeneratorImpl::get_stream_copy(VSLStreamStatePtr &streamCopy) {
  vslCopyStream(&streamCopy, stream_);
}

/**
 * Progresses the internal PRNG state n steps ahead --
 * used to account for variates generated by the copies
 * of the stream in MKLGenerator.
 * See Note [Acquire lock when using random generators]
 */
void MKLGeneratorImpl::skip_ahead(uint64_t n) {
  vslSkipAheadStream(stream_, n);
  this->advance_offset(n);
}

/**
 * Private clone method implementation
 * See Note [Acquire lock when using random generators]
 */
MKLGeneratorImpl* MKLGeneratorImpl::clone_impl() const {
  auto gen = new MKLGeneratorImpl();
  return gen;
}

/**
 * Public clone method implementation
 * See Note [Acquire lock when using random generators]
 */
std::shared_ptr<MKLGeneratorImpl> MKLGeneratorImpl::clone() const {
  return std::shared_ptr<MKLGeneratorImpl>(this->clone_impl());
}

/**
 * Sets the offset of RNG state.
 * See Note [Acquire lock when using random generators]
 */
void MKLGeneratorImpl::set_offset(uint64_t offset) {
  TORCH_CHECK(false, "MKL Generator does not allow to set offset");
}

/**
 * Gets the offset of RNG state.
 * See Note [Acquire lock when using random generators]
 */
uint64_t MKLGeneratorImpl::get_offset() const {
  return this->offset_;
}

/**
 * Private method to advance the offset of RNG state.
 * See Note [Acquire lock when using random generators]
 */
void MKLGeneratorImpl::advance_offset(uint64_t n) {
  this->offset_ += n;
}

/**
 * Gets the current internal state of MKLGeneratorImpl. The internal
 * state is returned as a CPU byte tensor.
 */
c10::intrusive_ptr<c10::TensorImpl> MKLGeneratorImpl::get_state() const {
  TORCH_CHECK(false, "MKL Generator does not use get_state");
}

/**
 * Sets the internal state of MKLGeneratorImpl. The new internal state
 * must be a strided CPU byte tensor.
 */
 void MKLGeneratorImpl::set_state(const c10::TensorImpl& new_state) {
  TORCH_CHECK(false, "MKL Generator does not use set_state");
}

} // namespace at
