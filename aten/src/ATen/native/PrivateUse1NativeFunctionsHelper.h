#pragma once

/*
 * PrivateUse1NativeFunctionsHelper.h
 *
 * This header serves as a dedicated extension utility for out-of-tree backends.
 * It provides specialized macros to streamline kernel implementations for the
 * PrivateUse1 ecosystem.
 *
 * These macros are designed to align with and extend the structured kernel
 * architecture defined in ATen/TensorMeta.h. While the core macros in TensorMeta.h
 * assume a global or anonymous namespace, this helper resolves definitions into
 * the backend-specific dispatch class (default: PrivateUse1NativeFunctions)
 * required by gen_backend_stubs.py.
 *
 */

// TORCH_PRIV1_CLASS resolves the target dispatch class for PrivateUse1 kernels.
// It aligns with the 'class_name' attribute used by gen_backend_stubs.py.
#ifndef TORCH_PRIV1_CLASS
#define TORCH_PRIV1_CLASS PrivateUse1NativeFunctions
#endif

// TORCH_PRIV1_FUNC is a specialized macro for non-structured backend operators.
// Example: Tensor TORCH_PRIV1_FUNC(add)(const Tensor& self, const Tensor& other)
#define TORCH_PRIV1_FUNC(name) TORCH_PRIV1_CLASS::name

/*
 * ----------------------------------------------------------------------------
 * PrivateUse1 Structured Kernel Macros
 * ----------------------------------------------------------------------------
 * NOTE ON NAMING CONVENTION:
 * Unlike internal ATen macros which may use functional overload names (e.g., Tensor),
 * PrivateUse1 macros are "Struct-Explicit." They must match the C++ struct names
 * generated by torchgen for your backend.
 *
 * * TORCH_PRIV1_META_FUNC(name):
 * Used for simple ops where the struct name is just 'structured_<name>'.
 * Example: min_dim, gelu_backward_grad_input
 *
 * * TORCH_PRIV1_META_FUNC2(name, overload):
 * Used when the struct name includes an overload suffix (name_overload).
 * Example: div, out_mode -> structured_div_out_mode
 * pow, Tensor_Tensor_out -> structured_pow_Tensor_Tensor_out
 *
 * This design ensures a 1:1 mapping with your Dispatcher registration and
 * makes the implementation easy to grep within your backend source code.
 * ----------------------------------------------------------------------------
 */

// TORCH_PRIV1_META_FUNC bridges backend-specific scoping with the structured
// meta-function hierarchy.
// Expansion: void <class_name>::structured_<op>::meta
#define TORCH_PRIV1_META_FUNC(name) \
  void TORCH_PRIV1_CLASS::structured_##name::meta

#define TORCH_PRIV1_META_FUNC2(name, overload) \
  void TORCH_PRIV1_CLASS::structured_##name##_##overload::meta

// TORCH_PRIV1_IMPL_FUNC defines the hardware-specific kernel implementation
// inside the backend's dispatch class scope.
#define TORCH_PRIV1_IMPL_FUNC(name) \
  void TORCH_PRIV1_CLASS::structured_##name::impl

// TORCH_PRIV1_PRECOMPUTE_META_FUNC handles meta-functions requiring
// precomputed value structs as specified in native_functions.yaml.
#define TORCH_PRIV1_PRECOMPUTE_META_FUNC(name) \
  TORCH_PRIV1_CLASS::structured_##name::meta_return_ty \
  TORCH_PRIV1_CLASS::structured_##name::meta

#define TORCH_PRIV1_PRECOMPUTE_META_FUNC2(name, overload) \
  TORCH_PRIV1_CLASS::structured_##name##_##overload::meta_return_ty \
  TORCH_PRIV1_CLASS::structured_##name##_##overload::meta

// TORCH_PRIV1_PRECOMPUTE_STRUCT provides access to the precompute_out struct.
#define TORCH_PRIV1_PRECOMPUTE_STRUCT(name) \
  TORCH_PRIV1_CLASS::structured_##name::precompute_out<>

#define TORCH_PRIV1_PRECOMPUTE_STRUCT2(name, overload) \
  TORCH_PRIV1_CLASS::structured_##name##_##overload::precompute_out<>
