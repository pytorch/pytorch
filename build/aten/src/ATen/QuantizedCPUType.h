#pragma once

// @generated by aten/src/ATen/gen.py

#include <c10/core/TensorOptions.h>
#include <c10/core/Scalar.h>
#include <c10/core/QScheme.h>
#include <c10/core/MemoryFormat.h>
#include <c10/util/ArrayRef.h>
#include <c10/util/intrusive_ptr.h>
#include <torch/csrc/WindowsTorchApiMacro.h>
#include <ATen/Dimname.h>
#include <ATen/core/EnableNamedTensor.h>



namespace c10 {
struct Storage;
}

namespace at {

class Tensor;
using TensorList = ArrayRef<Tensor>;

class Context;
struct Generator;

struct Quantizer;
// This is temporary typedef to enable Quantizer in aten native function API
// we'll remove them when we are actually exposing Quantizer class
// to frontend
using ConstQuantizerPtr = const c10::intrusive_ptr<Quantizer>&;

struct TORCH_API QuantizedCPUType final {
  static Tensor as_strided(const Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset);
  static Tensor _empty_affine_quantized(IntArrayRef size, const TensorOptions & options, double scale, int64_t zero_point, c10::optional<MemoryFormat> memory_format);
  static Tensor _empty_per_channel_affine_quantized(IntArrayRef size, const Tensor & scales, const Tensor & zero_points, int64_t axis, const TensorOptions & options, c10::optional<MemoryFormat> memory_format);
  static Tensor & resize_(Tensor & self, IntArrayRef size);
  static Tensor quantized_max_pool2d(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation);
  static Tensor mean(const Tensor & self, c10::optional<ScalarType> dtype);
  static Tensor mean(const Tensor & self, IntArrayRef dim, bool keepdim, c10::optional<ScalarType> dtype);
  static Tensor & mean_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim, c10::optional<ScalarType> dtype);
  static Tensor relu(const Tensor & self);
  static Tensor & relu_(Tensor & self);
  static Tensor clone(const Tensor & self);
  static Tensor dequantize(const Tensor & self);
  static double q_scale(const Tensor & self);
  static int64_t q_zero_point(const Tensor & self);
  static Tensor q_per_channel_scales(const Tensor & self);
  static Tensor q_per_channel_zero_points(const Tensor & self);
  static int64_t q_per_channel_axis(const Tensor & self);
  static Tensor int_repr(const Tensor & self);
  static QScheme qscheme(const Tensor & self);
  static Tensor & set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride);
  static Tensor & set_quantizer_(Tensor & self, ConstQuantizerPtr quantizer);
  static Tensor view(const Tensor & self, IntArrayRef size);
  static Tensor & ne_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor ne(const Tensor & self, Scalar other);
  static Tensor & ne_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor ne(const Tensor & self, const Tensor & other);
  static Tensor & eq_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor eq(const Tensor & self, Scalar other);
  static Tensor & eq_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor eq(const Tensor & self, const Tensor & other);
  static Tensor & ge_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor ge(const Tensor & self, Scalar other);
  static Tensor & ge_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor ge(const Tensor & self, const Tensor & other);
  static Tensor & le_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor le(const Tensor & self, Scalar other);
  static Tensor & le_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor le(const Tensor & self, const Tensor & other);
  static Tensor & gt_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor gt(const Tensor & self, Scalar other);
  static Tensor & gt_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor gt(const Tensor & self, const Tensor & other);
  static Tensor & lt_out(Tensor & out, const Tensor & self, Scalar other);
  static Tensor lt(const Tensor & self, Scalar other);
  static Tensor & lt_out(Tensor & out, const Tensor & self, const Tensor & other);
  static Tensor lt(const Tensor & self, const Tensor & other);
  static Tensor min(const Tensor & self);
  static Tensor max(const Tensor & self);
  static std::tuple<Tensor,Tensor> sort(const Tensor & self, int64_t dim, bool descending);
  static std::tuple<Tensor,Tensor> topk(const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted);
  static bool equal(const Tensor & self, const Tensor & other);
  static Tensor _adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size);
  static Tensor avg_pool2d(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override);
  static Tensor upsample_bilinear2d(const Tensor & self, IntArrayRef output_size, bool align_corners);
  static Tensor upsample_nearest2d(const Tensor & self, IntArrayRef output_size);
};

} // namespace at
